<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-02-21T19:51:02+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Rst</title><subtitle></subtitle><author><name>Wonbin Kim</name></author><entry><title type="html">[Oracle] Table 생성과 제약조건 (선언적 무결성 제약조건 추가하기)</title><link href="http://localhost:4000/oracle-create-table.html" rel="alternate" type="text/html" title="[Oracle] Table 생성과 제약조건 (선언적 무결성 제약조건 추가하기)" /><published>2020-02-20T00:00:00+09:00</published><updated>2020-02-20T00:00:00+09:00</updated><id>http://localhost:4000/oracle-create-table</id><content type="html" xml:base="http://localhost:4000/oracle-create-table.html">&lt;p&gt;Oracle에서 Table을 생성하고 제약조건을 추가하는 방법을 공부했다. 
그 방법을 정리하려 포스팅을 하게 되었다.&lt;/p&gt;

&lt;h2 id=&quot;테이블-만들기-기본적인-형태&quot;&gt;테이블 만들기: 기본적인 형태&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table [스키마.]&amp;lt;테이블 이름&amp;gt; (
&amp;lt;열 이름&amp;gt; &amp;lt;데이터 타입&amp;gt; [default &amp;lt;표현식&amp;gt;] [&amp;lt;제약조건&amp;gt;]
[,&amp;lt;열 이름&amp;gt; &amp;lt;데이터 타입&amp;gt; [default &amp;lt;표현식&amp;gt;] [&amp;lt;제약조건&amp;gt;]]
[,...]
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[]: 선택사항&lt;br /&gt;
&amp;lt;&amp;gt;: 필수사항&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;스키마&lt;/em&gt;: 만들어질 테이블이 속하는 스키마&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;테이블 이름&lt;/em&gt;: 만들어질 테이블의 이름&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;열 이름&lt;/em&gt;: 테이블의 열 이름&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;데이터 타입&lt;/em&gt;: 해당하는 열의 데이터 타입&lt;/li&gt;
  &lt;li&gt;*default &lt;표현식&gt;*: insert 구문에서 열의 값이 지정되지 않는 경우 
디폴트 값을 지정한다. &lt;표현식&gt;에는 정적값이나 sql함수를 지정할 수 있다.&lt;/표현식&gt;&lt;/표현식&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;제약조건&lt;/em&gt;: 각 열의 데이터가 갖춰야할 제약조건을 정의할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;테이블-만들기-select-구문-이용&quot;&gt;테이블 만들기: select 구문 이용&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;create table &amp;lt;table name&amp;gt; as select...&lt;/code&gt;형태의 구문으로 
select를 사용해 table을 생성할 수 있다.&lt;br /&gt;
&lt;strong&gt;예시&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table another_dept
as select * from scott.dept;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;제약조건이란&quot;&gt;제약조건이란?&lt;/h2&gt;
&lt;p&gt;Oracle은 데이터베이스의 데이터가 의도한 대로 저장되고 
데이터베이스의 다른 부분과 결함없이 작동하도록 제약조건을 제공한다.&lt;/p&gt;

&lt;p&gt;이때 제약조건을 적용하는 방법을 두가지로 분류할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;선언적 방법&lt;/strong&gt;: 
테이블의 선언(생성 및 변경)과 함께 규칙을 저장한다. 
테이블간의 관계에 대한 규칙, 테이블 열에 들어가야할 데이터의 규칙등을 지정한다. 
테이블에 저장되는 모든 행에 적용된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;절차적 방법&lt;/strong&gt;: 
작업과정중에는 데이터에 제약조건을 추가해야하는 상황이 발생하며 선언적 
방법만으로는 이를 충족하기 어렵다. 따라서 절차적 방법으로 
데이터에 제약조건을 추가하는데 이를 &lt;em&gt;사용자 정의 무결성&lt;/em&gt; 이라고 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 글에서는 Oracle의 &lt;strong&gt;선언적 무결성 제약조건&lt;/strong&gt; 추가방법을 알아보려한다.&lt;br /&gt;
Table을 새로 생성할때는 &lt;code class=&quot;highlighter-rouge&quot;&gt;create table&lt;/code&gt; 구문에서 제약조건을 추가 할 수 있다(앞에서 살펴봤다).&lt;br /&gt;
이미 존재하는 Table에 제약조건을 추가할 때는 아래와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;alter table add&lt;/code&gt;를 사용한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alter table [스키마.]&amp;lt;Table이름&amp;gt;
add [constraint &amp;lt;제약조건의 이름&amp;gt;]
&amp;lt;제약조건 정의&amp;gt;
/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;제약조건-추가하기-1-기본키-추가&quot;&gt;제약조건 추가하기: 1. 기본키 추가&lt;/h2&gt;
&lt;p&gt;기본키는 Table에서 각각의 행을 구분짓는 키의 역할을 한다. 
따라서 NULL이 될 수 없고 행을 구분 지을수 있도록 유일한 것 이어야 한다.&lt;br /&gt;
기본키는 하나의 열이나 여러개 열의 모음으로 정의할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 생성시 기본키 정의&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this_is_test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 sql을 실행한 결과는 아래와 같은데 NO 항목이 기본키(Primary Key)로 
정의된 것을 확인할 수 있다.&lt;br /&gt;
&lt;img src=&quot;/assets/img/2020-02-20-oracle-create-table/pk1.png&quot; alt=&quot;pk&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이미 생성된 Table에 기본키 제약조건 적용&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this_is_test&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constraint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ct_name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;제약조건-추가하기-2-외부키-추가&quot;&gt;제약조건 추가하기: 2. 외부키 추가&lt;/h2&gt;
&lt;p&gt;외부키는 다른 Table과 연결되는 기능을 한다.&lt;br /&gt;
이때 테이블간에 부모-자식 관계가 발생한다. 제약조건이 적용되는 테이블은 
자식이고 그것이 아닌쪽이 부모이다.&lt;/p&gt;

&lt;p&gt;외부키를 적용할때 &lt;code class=&quot;highlighter-rouge&quot;&gt;references&lt;/code&gt;라는 키워드로 부모 테이블과 연결 시킨다.&lt;/p&gt;

&lt;p&gt;이미 존재하는 테이블에는 다음과 같이 사용한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
alter table [스키마.]&amp;lt;Table이름&amp;gt;
add [constraint &amp;lt;제약조건의 이름&amp;gt;]
foreign key (&amp;lt;외부키에 해당되는 한 열 또는 여러 열&amp;gt;)
references &amp;lt;부모테이블 이름&amp;gt; (&amp;lt;외부키와 연결되는 한 열 또는 여러 열&amp;gt;)
/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테이블 생성시 외부키 정의방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;references&lt;/code&gt;키워드만 사용한다.&lt;br /&gt;
&lt;strong&gt;테이블 생성 예시&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;references&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;제약조건-추가하기-3-유일조건-추가&quot;&gt;제약조건 추가하기: 3. 유일조건 추가&lt;/h2&gt;
&lt;p&gt;유일조건은 지정하는 열들이 NULL값이 아닐때 
테이블내에서 행마다 유일하도록 하는 제약조건이다.&lt;br /&gt;
곧 행을 구분할 수 있는 수단이 될 수 있다.&lt;/p&gt;

&lt;p&gt;다음의 방법으로 사용하면 된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unique(&amp;lt;열1&amp;gt;[,&amp;lt;열2&amp;gt;][,...])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;제약조건-추가하기-4-check조건-추가&quot;&gt;제약조건 추가하기: 4. CHECK조건 추가&lt;/h2&gt;
&lt;p&gt;이 조건은 테이블 내의 모든 행에 적용되는 조건이다.&lt;br /&gt;
대상이 되는 행이 check 조건을 만족해야한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;people_who_is_male&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constraint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;check_gender&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gender&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'MALE'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 예시에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;gender&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;people_who_is_male&lt;/code&gt;테이블의 
열이다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="oracle" /><category term="sql" /><summary type="html">Oracle에서 Table을 생성하고 제약조건을 추가하는 방법을 공부했다. 그 방법을 정리하려 포스팅을 하게 되었다. 테이블 만들기: 기본적인 형태</summary></entry><entry><title type="html">[Oracle] 스키마 생성, 권한부여, 수정, 삭제</title><link href="http://localhost:4000/oracle-user-create-grant-alter.html" rel="alternate" type="text/html" title="[Oracle] 스키마 생성, 권한부여, 수정, 삭제" /><published>2020-02-19T00:00:00+09:00</published><updated>2020-02-19T00:00:00+09:00</updated><id>http://localhost:4000/oracle-user-create-grant-alter</id><content type="html" xml:base="http://localhost:4000/oracle-user-create-grant-alter.html">&lt;h2 id=&quot;사용자-생성하기-create-user&quot;&gt;사용자 생성하기: ‘create user’&lt;/h2&gt;
&lt;p&gt;oracle에서 사용자(스키마)를 생성하기 위해선 create user 
명령을 사용한다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;identified&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;사용자에게-권한-부여하기&quot;&gt;사용자에게 권한 부여하기&lt;/h2&gt;
&lt;p&gt;oracle에서 사용자에게 권한을 부여하기 위해선 &lt;code class=&quot;highlighter-rouge&quot;&gt;grant ... to ...&lt;/code&gt;
명령을 사용한다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;권한&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;권한&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;사용자-관련-사항-수정하기-alter-user&quot;&gt;사용자 관련 사항 수정하기: alter user&lt;/h2&gt;
&lt;p&gt;사용자 계정과 관련된 사항을 수정할때는 &lt;code class=&quot;highlighter-rouge&quot;&gt;alter user&lt;/code&gt;로 시작하는 
구문을 이용해 수정한다.&lt;/p&gt;
&lt;h3 id=&quot;1-암호-변경하기&quot;&gt;1. 암호 변경하기&lt;/h3&gt;
&lt;p&gt;사용자를 생성할때 사용한 암호 정의 구문을 이용한다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;identified&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-계정-잠금해제&quot;&gt;2. 계정 잠금/해제&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;3-테이블-스페이스-변경&quot;&gt;3. 테이블 스페이스 변경&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;defualt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tablespace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;space&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;temporary&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tablespace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;space&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;4-테이블-스페이스-할당량-변경&quot;&gt;4. 테이블 스페이스 할당량 변경&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;quota &amp;lt;할당량&amp;gt; on &amp;lt;tablespace 이름&amp;gt;&lt;/code&gt;을 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;quota&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlimited&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;quota&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;temp&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;사용자-삭제하기&quot;&gt;사용자 삭제하기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;drop user&lt;/code&gt; 명령을 사용한다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="oracle" /><category term="sql" /><summary type="html">사용자 생성하기: ‘create user’ oracle에서 사용자(스키마)를 생성하기 위해선 create user 명령을 사용한다. create user &amp;lt;user name&amp;gt; identified by &amp;lt;user password&amp;gt;; 사용자에게 권한 부여하기 oracle에서 사용자에게 권한을 부여하기 위해선 grant ... to ... 명령을 사용한다. grant &amp;lt;권한1&amp;gt;, &amp;lt;권한2&amp;gt;,... to &amp;lt;user name&amp;gt;;</summary></entry><entry><title type="html">이벤트 기반 비동기 방식이란? 어떻게 동작하는거지? Node.js Javascript</title><link href="http://localhost:4000/nodejs-what-is-event-based-programming.html" rel="alternate" type="text/html" title="이벤트 기반 비동기 방식이란? 어떻게 동작하는거지? Node.js Javascript" /><published>2020-02-07T00:00:00+09:00</published><updated>2020-02-07T00:00:00+09:00</updated><id>http://localhost:4000/nodejs-what-is-event-based-programming</id><content type="html" xml:base="http://localhost:4000/nodejs-what-is-event-based-programming.html">&lt;h1 id=&quot;배경&quot;&gt;배경&lt;/h1&gt;
&lt;p&gt;Node.js를 처음 접했을때 &lt;em&gt;이벤트 기반 비동기 처리&lt;/em&gt; 방식을
사용한다는 사실을 알게됐다. &lt;em&gt;모던 웹을 위한 Node.js 프로그래밍&lt;/em&gt;
이라는 책에서는 이 방식을 아래의 &lt;em&gt;시장 대기표&lt;/em&gt; 예시로
설명했다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;시장 여러곳의 가게에서 물건을 구매해야한다.&lt;br /&gt;
이때 각 가게에는 손님들이 줄을 서서 대기하고 있다.&lt;br /&gt;
빠르게 모든 물건을 구매하기 위해선 두가지 방법이 있는데&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;몸을 복제해 동시에 여러가게에 간다.&lt;/li&gt;
  &lt;li&gt;시장을 대기표를 나누어주는 시스템으로 바꾸고
대기표만 받고 기다린다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1번의 방식은 기존의 스레드 기반 네트워크 프로그램의 방식이며,&lt;br /&gt;
2번은 이벤트 기반 비동기 방식이다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;이 예시를 통해서 이벤트 기반 비동기 방시기 어떤
방식인지 이해할 순 있었다. 하지만 이것이 어떻게 가능한지,
진짜 단일 스레드로 가능한건지 궁금해졌다.&lt;/p&gt;

&lt;h1 id=&quot;multi-thread-방식&quot;&gt;Multi Thread 방식&lt;/h1&gt;
&lt;p&gt;Multi Thread 방식의 서버의 요청처리는 각 요청마다
새로운 Thread를 발생시켜 처리하는 방식이다.
아래의 java코드로 이해해 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//server-socket 80번 포트에서 bind&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ServerSocket&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServerSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//연결 생성&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Socket&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//새로운 스레드 발생시켜 처리과정 넘기기&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;MutiThreadHttp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutiThreadHttp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//스레드 시작             &lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 방식은 클라이언트 요청이 몰릴수록 그에 대응되는 많은
스레드가 발생하므로 메모리 자원을
많이 소모하게 된다. 즉 서버의 자원에 제한을 받는다.&lt;br /&gt;
또 프로그래밍시 Thread간 공유자원 관리에 주의 해야하는
단점이 있다.&lt;/p&gt;

&lt;h1 id=&quot;이벤트-기반-비동기-방식&quot;&gt;이벤트 기반 비동기 방식&lt;/h1&gt;
&lt;p&gt;javascript는 이벤트 기반 비동기 방식으로 작동한다.&lt;br /&gt;
이 방식을 따르는 Node.js는 여러 클라이언트들의 요청을
하나의 스레드로 처리하며 각각의 요청에서 이벤트가 발생할 때만 그에 맞는 작업을 처리한다.&lt;/p&gt;

&lt;p&gt;어떠한 원리로 이벤트 기반 비동기 방식이 작동하는지 궁금해졌고
아래의 문서들을 통해 이해할 수 있었다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40&quot;&gt;Understanding JS: The Event Loop&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.nextree.co.kr/p7292/&quot;&gt;Node.js: 비동기 프로그래밍 이해&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이벤트 기반 비동기 방식은 &lt;strong&gt;Event Loop&lt;/strong&gt;에 의해 이루어진다.
Node.js에서 클라이언트의 요청을 처리하는 방식을 보면
이해할 수 있다.&lt;br /&gt;
&lt;img src=&quot;/assets/img/what-is-event-based-programming-javascript.jpg&quot; alt=&quot;eventbased-eg-req&quot; /&gt;&lt;br /&gt;
위와같이 할 수 있는 이유는 요청에서 발생하는 이벤트와 콜백들을
이벤트 루프에서 처리하기 때문이다.
이 과정을 이해하려면 Call Stack, Event Table, Event Queue
에 대해 알아야한다.&lt;/p&gt;

&lt;h2 id=&quot;call-stack&quot;&gt;Call Stack&lt;/h2&gt;
&lt;p&gt;Javascript에서 함수를 호출하게 되면 이를 Callstack에 넣는다.&lt;br /&gt;
이름 그대로 Stack이므로 나중에 들어간 함수가 먼저 실행되고
먼저들어간 함수가 나중에 실행된다.&lt;br /&gt;
실행중인 함수가 다른 함수를 호출하면 호출받은 함수가
Callstack의 맨 위에 올려진다.&lt;/p&gt;

&lt;p&gt;Javascript는 오직 하나의 Callstack을 가져서 모든 함수의 실행은
Callstack에서 이루어진다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 Callstack만으로는 javascript가 이벤트를 비동기처리 하는
과정을 설명할 수 없다.&lt;br /&gt;
예를들어 10초후에 특정함수가 실행되도록 타이머를 설정한다면,
모든 처리가 10초 늦춰진다고 밖에 설명할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;event-table-event-queue&quot;&gt;Event Table, Event Queue&lt;/h2&gt;
&lt;p&gt;위의 예시와같이 이벤트가 발생해야 실행되는 함수를 Event Table
에서 저장한다. 이때 Event Table은 특정 이벤트와 그에 대응되는
함수를 저장하고 이벤트가 발생하면 대응되는 함수를 Event Queue에
넣는다.&lt;/p&gt;

&lt;p&gt;Event Queue는 말 그대로 ‘큐’이므로 들어온 순서대로 함수를
수행한다.&lt;br /&gt;
하지만 함수를 실행시키는것은 Callstack에 쌓인 함수만 가능하므로
아직 수행해야할 작업이 남아있다.&lt;/p&gt;

&lt;h2 id=&quot;event-loop&quot;&gt;Event Loop&lt;/h2&gt;
&lt;p&gt;Event Loop는 이벤트에 대응되는 함수를 Callstack에 쌓는
역할을 한다.&lt;br /&gt;
작업의 과정은 다음과 같이 진행된다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Callstack이 비어있는지 확인한다.&lt;/li&gt;
  &lt;li&gt;비어있다면 Event Queue가 비어있는지 확인한다.&lt;/li&gt;
  &lt;li&gt;큐가 비어있지 않다면 Event Queue의 앞에서 함수를 가져와 Callstack에 쌓는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;결론&quot;&gt;결론&lt;/h1&gt;
&lt;p&gt;전체적으로 Event Loop를 통해 이벤트 기반 비동기 방식이 작동한다.&lt;br /&gt;
곧 코드작성자의 코드가 하나의 Thread에 기반해서 실행될 수 있도록
내부적으로 여러개의 Thread를 발생시키는 방법인것이다.&lt;/p&gt;

&lt;p&gt;지금까지 살펴본 Event Loop의 작업방식을 확인해 볼 수 있는
코드가 있다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;실행시켜보면 ‘second’가 먼저 출력되고 ‘first’가 나중에 출력된다.&lt;br /&gt;
다음의 과정으로 처리가 된 것이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;setTimeout()이 호출되어 콜스택에서 실행된다.&lt;/li&gt;
  &lt;li&gt;event table에 ‘first’출력 함수가 저장된다.&lt;/li&gt;
  &lt;li&gt;‘second’출력이 콜스텍에 올라가고 ‘first’출력이 이벤트 큐에 올라간다.&lt;/li&gt;
  &lt;li&gt;Event Loop는 콜스텍이 비어야 Event Queue에서 함수를 꺼내오므로 ‘second’출력이 먼저 발생하고 ‘first’출력이 콜스텍에 올라가 실행된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이벤트 기반 비동기 방식은 Multi Thread 방식보다 Thread를 적게
사용하여 메모리 자원을 절약할 수 있는 이점이 있다.&lt;br /&gt;
하지만 각각의 이벤트들이 많은 연산이 필요하거나 대용량의 IO를
다루는 작업등의 많은 시간이 필요한 작업이라면 성능의 저하를
가져올 수 있다.&lt;/p&gt;

&lt;p&gt;프로그래밍시 주의해야 할 점은 javascript가 비동기 언어라는
점을 꼭 인식해야한다는 것이다.&lt;br /&gt;
자신이 작성한 코드중 무엇이 먼저 실행될지 모르기 때문에
콜백방법을 이용하여 순차적으로 실행되도록 해야한다.&lt;br /&gt;
또, 콜백함수를 받는 함수를 작성할때도 비동기적 방식으로 처리된다는
것을 유의하고 콜백함수를(콜백을 쓰거나 다른 라이브러리를 사용하여)
원하는 시점에 실행시키도록 주의해야한다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="node.js" /><category term="javascript" /><summary type="html">배경 Node.js를 처음 접했을때 이벤트 기반 비동기 처리 방식을 사용한다는 사실을 알게됐다. 모던 웹을 위한 Node.js 프로그래밍 이라는 책에서는 이 방식을 아래의 시장 대기표 예시로 설명했다. 시장 여러곳의 가게에서 물건을 구매해야한다. 이때 각 가게에는 손님들이 줄을 서서 대기하고 있다. 빠르게 모든 물건을 구매하기 위해선 두가지 방법이 있는데 몸을 복제해 동시에 여러가게에 간다. 시장을 대기표를 나누어주는 시스템으로 바꾸고 대기표만 받고 기다린다.</summary></entry><entry><title type="html">[Node.js] 전역 변수, 전역 객체 (console, process, exports)</title><link href="http://localhost:4000/nodejs-global-objects.html" rel="alternate" type="text/html" title="[Node.js] 전역 변수, 전역 객체 (console, process, exports)" /><published>2020-02-03T00:00:00+09:00</published><updated>2020-02-03T00:00:00+09:00</updated><id>http://localhost:4000/nodejs-global-objects</id><content type="html" xml:base="http://localhost:4000/nodejs-global-objects.html">&lt;p&gt;이 글은 Node.js의 전역 변수와 전역 객체를
정리한 글 입니다.&lt;/p&gt;

&lt;h1 id=&quot;전역-변수&quot;&gt;전역 변수&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__filename&lt;/code&gt;: 현재 실행중인 코드의 파일 경로를 가지는 문자열&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__dirname&lt;/code&gt;: 현재 실행중인 코드의 디렉토리 경로를 가지는 문자열&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;console-객체&quot;&gt;console 객체&lt;/h1&gt;
&lt;p&gt;console 객체는 Node.js의 콘솔화면 기능을 다룹니다. console 객체의 메서드는 아래와 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;log()&lt;/code&gt;: print 기능을 가지며 특수문자를 
이용해 문자열을 출력할 수 있습니다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%d&lt;/code&gt;: 숫자&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;: 문자열&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%j&lt;/code&gt;: JSON&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;time(label)&lt;/code&gt;: 시간 측정을 시작합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timeEnd(label)&lt;/code&gt;: 시간 측정을 종료합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;예시 코드&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log(&quot;%d * %d = %s&quot;, 10, 10, '100');
console.log(&quot;json: %j&quot;, {&quot;name&quot; : &quot;rst&quot;});

console.time('t');
for(var i=0; i&amp;lt;99999; i++);
console.timeEnd('t');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;결과&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10 * 10 = 100
{&quot;name&quot;:&quot;rst}
t: 18172.890ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;process-객체&quot;&gt;process 객체&lt;/h1&gt;
&lt;p&gt;process 객체는 프로그램과 관련된 정보를 포함하는 객체입니다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;process 객체의 속성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;argv&lt;/code&gt;: 실행 매개 변수를 포함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;env&lt;/code&gt;: 컴퓨터 환경 정보 포함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;version&lt;/code&gt;: Node.js의 버전 정보&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;versions&lt;/code&gt;: Node.js와 종속된 프로그램의 버전 정보&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arch&lt;/code&gt;: 프로세서의 아키텍쳐&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;platform&lt;/code&gt;: 플랫포 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;process 객체의 메서드&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exit()&lt;/code&gt;: 프로그램 종료&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memoryUsage()&lt;/code&gt;: 메모리 사용 정보 객체를 리턴&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uptime()&lt;/code&gt;: 현재 프로그램이 실행된 시간을 리턴&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;exports-객체&quot;&gt;exports 객체&lt;/h1&gt;
&lt;p&gt;exports 객체는 모듈을 생성할때 사용합니다.&lt;br /&gt;
exports 객체의 속성을 정의하는 방식으로 작동합니다. 
예시를 보는것이 이해하기 쉽습니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;md.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;app.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;md&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./md.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;md&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;언급하지 않아도 되겠지만 결과는 &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;가 출력됩니다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="node.js" /><summary type="html">이 글은 Node.js의 전역 변수와 전역 객체를 정리한 글 입니다.</summary></entry><entry><title type="html">[Javascript] Callback 함수 with JQuery effect</title><link href="http://localhost:4000/javascript-callback-with-jquery-effect.html" rel="alternate" type="text/html" title="[Javascript] Callback 함수 with JQuery effect" /><published>2020-01-30T00:00:00+09:00</published><updated>2020-01-30T00:00:00+09:00</updated><id>http://localhost:4000/javascript-callback-with-jquery-effect</id><content type="html" xml:base="http://localhost:4000/javascript-callback-with-jquery-effect.html">&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;배경&quot;&gt;배경&lt;/h2&gt;
&lt;p&gt;javascript는 한 문장씩 순차적으로 실행되는 언어이다.
하지만 애니메이션등의 효과를 사용하게되면 효과를 모두 마치기 
전에 다음 문장이 실행됨을 볼 수 있다.&lt;br /&gt;
다음의 코드를 실행시켜보면 쉽게 이해할 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;click&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;click&lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pp&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;저는 알림이 뜨기전에 사라지고 싶어요&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;#click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;#pp&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slideUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;slow&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;어림도 없지!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div style=&quot;border-style: solid; border-color: green;&quot;&gt;
&lt;button id=&quot;click&quot;&gt;click&lt;/button&gt;
&lt;p id=&quot;pp&quot;&gt;저는 알림이 뜨기전에 사라지고 싶어요&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    $(&quot;#click&quot;).click(
        function(){
            $(&quot;#pp&quot;).slideUp(&quot;slow&quot;);
            alert(&quot;어림도 없지!&quot;);
        }
    );
&lt;/script&gt;

&lt;p&gt;이러한 문제는 애니메이션 효과뿐만이 아니라
javascript를 사용하는 여러순간에 발생할 수 있다.
이를 해결하기 위해 Callback기능을 이용한다.&lt;/p&gt;

&lt;h2 id=&quot;사용방법&quot;&gt;사용방법&lt;/h2&gt;
&lt;p&gt;애니메이션 효과의 경우 다음과 같은 형식으로 사용할 수 있다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;$(selector).effect(speed, callback)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;effect는 slideUp, hide와 같은 효과 함수들을 가리킨다.&lt;/li&gt;
  &lt;li&gt;callback은 함수이다. 효과가 다 끝나고 함수가 실행된다.&lt;br /&gt;
아래의 예시를 실행해보자&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;click&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;click&lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pp&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;저는 알림이 뜨기전에 사라지고 싶어요&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;#click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;#pp&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slideUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;slow&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
                &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;그렇게 하렴~&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
            
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div style=&quot;border-style: solid; border-color: green;&quot;&gt;
&lt;button id=&quot;clickk&quot;&gt;click&lt;/button&gt;
&lt;p id=&quot;pppp&quot;&gt;저는 알림이 뜨기전에 사라지고 싶어요&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    $(&quot;#clickk&quot;).click(
        function(){
            $(&quot;#pppp&quot;).slideUp(&quot;slow&quot;,
            function(){
                alert(&quot;그렇게 하렴~&quot;);
            });
        }
    );
&lt;/script&gt;

&lt;h2 id=&quot;마치며-새롭게-알게된점&quot;&gt;마치며, 새롭게 알게된점&lt;/h2&gt;
&lt;p&gt;javascript의 callback함수를 ‘애니메이션 효과’에 관련된 부분의 공부를 하면서 ‘순차적 실행’에 관련해서만 이해했었다. 하지만 조금더 깊게 공부를 해보니 
&lt;code class=&quot;highlighter-rouge&quot;&gt;$(selector).click(function(){...})&lt;/code&gt; 과 같은 jquery 구문도 callback을 
이용한다는 사실을 알게되었다.&lt;/p&gt;

&lt;p&gt;자바스크립트에서는 함수가 객체로 사용된다.
함수1이 함수2를 파라미터로 받고 실행중 혹은 실행 마지막( 애니메이션 효과가 끝날때 
처럼 )에서 함수2를 실행시킨다면 함수2를 콜백함수라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 개념은 함수형 프로그래밍의 개념이라는데 좀 더 찾아봐야겠다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="javascript" /><category term="jquery" /><summary type="html"></summary></entry><entry><title type="html">[HTML5] Outline과 Section</title><link href="http://localhost:4000/html5-outlines-and-section.html" rel="alternate" type="text/html" title="[HTML5] Outline과 Section" /><published>2020-01-18T00:00:00+09:00</published><updated>2020-01-18T00:00:00+09:00</updated><id>http://localhost:4000/html5-outlines-and-section</id><content type="html" xml:base="http://localhost:4000/html5-outlines-and-section.html">&lt;ul&gt;
  &lt;li&gt;이 글은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTML/HTML5_%EB%AC%B8%EC%84%9C%EC%9D%98_%EC%84%B9%EC%85%98%EA%B3%BC_%EC%9C%A4%EA%B3%BD&quot;&gt;MDN문서&lt;/a&gt;와 &lt;a href=&quot;https://m5designstudio.com/2013/orlando-web-design/html5-for-beginners-2&quot;&gt;M5 design studio&lt;/a&gt;를 참고하여 작성한 글 입니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gsnedders.html5.org/outliner/&quot;&gt;HTML5 Outliner&lt;/a&gt;을 이용하면 아웃라인을 확인할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;outline&quot;&gt;Outline&lt;/h1&gt;
&lt;p&gt;HTML5에서는 이전보다 파악하기 쉬운 아웃라인을 사용합니다. 
아웃라인은 ‘섹션의 계층구조(트리구조)’라고 이해할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;Section&lt;/h1&gt;
&lt;p&gt;HTML5에서는 명시적인 방법과 비명시적인 방법으로 문서를 부분(section)으로 나눌수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;명시적-섹션&quot;&gt;명시적 섹션&lt;/h2&gt;
&lt;p&gt;아래의 태그들을 사용합니다.
&lt;img src=&quot;https://m5designstudio.com/wp-content/uploads/2013/01/HTML5_website_structure.jpg&quot; alt=&quot;dd&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;도 섹션 태그입니다. 각 섹션은 제목(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;부터&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;)을 가질 수 있으며 제목은 섹션내의 가장 위에 위치한 태그만 해당합니다. 그 외의 제목태그들은 뒤에서 설명할 비명시적인 섹션을 만들어냅니다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;body&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;section&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;body-s&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;section&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;body-s-s&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/section&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/section&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;section&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;body-s-2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/section&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 코드는 아래의 아웃라인을 갖게됩니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. body
    1. body-s
        1. body-s-s
    2. body-s-2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이를 통해 섹션으로 계층구조가 나눠짐을 알 수 있습니다. 
하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;header&amp;gt;&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;태그는 웹문서의 주요 아웃라인에 속하지 않습니다. 즉, 이 태그들은 해당 html5 문서의 주요 맥락에서 벗어난 내용을 다루는 용도로 사용됩니다.&lt;/p&gt;
&lt;h2 id=&quot;비명시적-섹션&quot;&gt;비명시적 섹션&lt;/h2&gt;
&lt;p&gt;제목 태그(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;)는 자신이 속한 섹션의 첫번째 제목으로 정의되지 않았다면 비명시적(암묵적)으로 새로운 섹션으로 분류됩니다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="html5" /><category term="web" /><summary type="html">이 글은 MDN문서와 M5 design studio를 참고하여 작성한 글 입니다. HTML5 Outliner을 이용하면 아웃라인을 확인할 수 있습니다. Outline HTML5에서는 이전보다 파악하기 쉬운 아웃라인을 사용합니다. 아웃라인은 ‘섹션의 계층구조(트리구조)’라고 이해할 수 있습니다.</summary></entry><entry><title type="html">[Git] 1.버전생성</title><link href="http://localhost:4000/git/git-1-create-version.html" rel="alternate" type="text/html" title="[Git] 1.버전생성" /><published>2020-01-14T00:00:00+09:00</published><updated>2020-01-14T00:00:00+09:00</updated><id>http://localhost:4000/git/git-%201-create-version</id><content type="html" xml:base="http://localhost:4000/git/git-1-create-version.html">&lt;h2 id=&quot;버전관리&quot;&gt;버전관리&lt;/h2&gt;
&lt;p&gt;git은 버전관리를 제공하는 소프트웨어이며 ‘.git’폴더에서 변경사항을 관리한다.&lt;br /&gt;
아래의 용어들을 통해 git이 작동하는 방식을 알 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;repository: 버전이 저장되어있는곳(.git 폴더로 생각할 수 있다.)&lt;/li&gt;
  &lt;li&gt;working tree: 변경사항들이 버전으로 전환되기 전 단계&lt;/li&gt;
  &lt;li&gt;staging area: working tree에서 버전으로 저장할 파일들을 선택하여 올려놓는 공간.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;버전관리-시작&quot;&gt;버전관리 시작&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git init .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;여기서 .은 현재 디렉토리를 가리킨다.
이 명령을 수행하면 해당 디렉토리에 ‘.git’이라는 폴더가 생성된다.
이 폴더안의 데이터를 이용해 git이 버전관리를 한다.&lt;/p&gt;

&lt;h2 id=&quot;버전-생성&quot;&gt;버전 생성&lt;/h2&gt;

&lt;p&gt;git은 버전관리를 했던 파일에 대해 추적을 한다.&lt;br /&gt;
즉 버전관리를 하지 않은 파일은 추적하지 않는다.&lt;br /&gt;
대상 파일을 staging area로 올리면 버전관리의 대상이 된다.&lt;br /&gt;
staging area로 올리기 위해선 &lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt; 명령을 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add file.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 commit 명령을 하면 버전이 생성된다.
곧 repository에 저장되는것이다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit -m &quot;this is message&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;확인하기위해선 &lt;code class=&quot;highlighter-rouge&quot;&gt;log&lt;/code&gt;명령을 하면 된다. &lt;a href=&quot;https://git-scm.com/docs/git-log&quot;&gt;git 문서 참조&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 git이 추적하는 파일을 수정하면 어떻게 될까?
파일 수정후 status 명령을 하면&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git restore &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
        modified:   file.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘changes not staged for commit’ 메세지를 보면 수정된 file.txt파일이 staging area에 올라가 있지 않다는 것을 알 수 있다.&lt;br /&gt;
즉 working tree에 변경사항이 있다는 것이며 &lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt; 명령으로 staging area에 추가하여 commit의 대상으로 지정할 수 있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add file.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이후 commit 명령을 하면 변경사항이 repository에 저장되며
git log 명령을 통해 확인할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;편의를-위한-명령어들&quot;&gt;편의를 위한 명령어들&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add .
#현재폴더의 모든 파일을 staging area에 올린다.

git commit -am &quot;this is message&quot;
#-am은 add와 message기능을 사용한다는 의미
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Wonbin Kim</name></author><category term="git" /><summary type="html">버전관리 git은 버전관리를 제공하는 소프트웨어이며 ‘.git’폴더에서 변경사항을 관리한다. 아래의 용어들을 통해 git이 작동하는 방식을 알 수 있다. repository: 버전이 저장되어있는곳(.git 폴더로 생각할 수 있다.) working tree: 변경사항들이 버전으로 전환되기 전 단계 staging area: working tree에서 버전으로 저장할 파일들을 선택하여 올려놓는 공간.</summary></entry><entry><title type="html">[Git] 2.Checkout</title><link href="http://localhost:4000/git/git-2-checkout.html" rel="alternate" type="text/html" title="[Git] 2.Checkout" /><published>2020-01-14T00:00:00+09:00</published><updated>2020-01-14T00:00:00+09:00</updated><id>http://localhost:4000/git/git-2-checkout</id><content type="html" xml:base="http://localhost:4000/git/git-2-checkout.html"></content><author><name>Wonbin Kim</name></author><category term="git" /><summary type="html"></summary></entry></feed>