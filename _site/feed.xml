<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-04-09T04:51:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Rst</title><subtitle></subtitle><author><name>Wonbin Kim</name></author><entry><title type="html">[Jekyll, Github Page] 카테고리 페이지 만들기</title><link href="http://localhost:4000/jekyll/making-category-page.html" rel="alternate" type="text/html" title="[Jekyll, Github Page] 카테고리 페이지 만들기" /><published>2022-04-08T00:00:00+09:00</published><updated>2022-04-08T00:00:00+09:00</updated><id>http://localhost:4000/jekyll/making-category-page</id><content type="html" xml:base="http://localhost:4000/jekyll/making-category-page.html"><![CDATA[<p>Github 블로그 포스팅을 정리하던중 카테고리 페이지의 필요성을 느꼈다.<br />
<a href="https://jekyllrb.com/docs/variables/">Jekyll Docs</a>에 설명되어있는 변수들을 잘 이용하면 카테고리 페이지를 만들수 있다!<br />
아래의 순서로 만들어보았다.</p>

<ol>
  <li>Post에서 카테고리를 지정, 보여주기</li>
  <li>카테고리별 페이지 만들기</li>
  <li>전체 카테고리 리스트를 보여주는 페이지 만들기</li>
</ol>

<p>코드의 이해를 돕기위해 상황을 가정해보자.<br />
git에 대한 포스팅을 작성하는데 이 포스팅을 카테고리로 분류하고 싶은상황이다.<br />
git은 개발도구이므로 <code class="language-plaintext highlighter-rouge">Tools</code>와 <code class="language-plaintext highlighter-rouge">Git</code>카테고리를 만들기로했으며 <code class="language-plaintext highlighter-rouge">Tools</code>카테고리 안에 <code class="language-plaintext highlighter-rouge">Git</code>카테고리가 포함되도록 만들어야한다.</p>

<h2 id="1-post에서-카테고리-지정하기-페이지에-카테고리-표시하기">1. Post에서 카테고리 지정하기, 페이지에 카테고리 표시하기</h2>
<h3 id="11-카테고리-지정하기">1.1 카테고리 지정하기</h3>
<p>이때 <a href="https://jekyllrb.com/docs/front-matter/">FrontMatter</a>에서 지정할 수 있는 <code class="language-plaintext highlighter-rouge">categories</code>라는 변수를 이용한다. 
(FrontMatter는 Jekyll에 페이지의 Metadata를 알려주는 역할을 한다.)<br />
문자열 혹은 배열의 형태로도 지정이 가능하다.<br />
필자는 배열로 카테고리를 지정했으며 배열원소의 순서를 이용해 카테고리의 상하관계를 나타냈다.</p>
<div class="language-liquid highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: post
categories: ["Tools", "Git"]
title: "Git 외부 저장소 연결하기"
---
...포스팅 내용
</code></pre></div></div>
<h3 id="12-카테고리-정보를-페이지에서-보여주기">1.2 카테고리 정보를 페이지에서 보여주기</h3>
<p>위의 post는 <code class="language-plaintext highlighter-rouge">post</code>라는 layout을 가진다.<br />
해당하는 <code class="language-plaintext highlighter-rouge">/_layouts/post.html</code>레이아웃에 아래의 코드를 추가해주자</p>

<script src="https://gist.github.com/rst0070/15465a3c2e79bde88a80139f36574596.js"></script>

<p><code class="language-plaintext highlighter-rouge">page.categories</code>변수를 이용해 포스팅에서 지정된 카테고리의 링크를 보여주도록 만들었다. 
가정한 상황에선 <code class="language-plaintext highlighter-rouge">../category/Tools.html</code>, <code class="language-plaintext highlighter-rouge">../category/Git.html</code>링크가 보여질것이다.</p>

<h2 id="2-카테고리별-페이지-만들기">2. 카테고리별 페이지 만들기</h2>
<p>앞에서 카테고리 페이지에 접근할 수 있게 만들었으니 이번에는 카테고리 페이지를 만들자.</p>
<h3 id="21-카테고리별-페이지">2.1 카테고리별 페이지</h3>
<p><code class="language-plaintext highlighter-rouge">/category/Tools.html</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: category
categories: ["Tools"]
title: "Tools"
---
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">/category/Tools-Git.html</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: category
categories: ["Tools", "Git"]
title: "Tools/Git"
permalink: /category/Git.html
---
</code></pre></div></div>
<p>위의 <code class="language-plaintext highlighter-rouge">permalink</code>는 페이지의 url을 지정해준다. 파일명을 카테고리 구조에 맞게 작성했기때문에 추가해주었다.</p>

<h3 id="22-category-layout">2.2 category layout</h3>
<p>여러개의 카테고리가 있을것이기 때문에 <code class="language-plaintext highlighter-rouge">category</code>라는 레이아웃을 지정했는데 이것도 만들어야한다.<br />
<code class="language-plaintext highlighter-rouge">/_layouts/category.html</code>에 만들어주자</p>

<script src="https://gist.github.com/rst0070/3cefb95fd4f5c0e8ceef1668884af726.js"></script>

<p><a href="https://selosele.github.io/liquid/filters/join/">join 필터</a>를 사용하여 카테고리 페이지의 <code class="language-plaintext highlighter-rouge">categories</code> 배열을 문자열화 시키고
사이트의 모든 포스트들을 확인하며 각 포스트의 <code class="language-plaintext highlighter-rouge">categories</code>배열을 문자열화 시켜서 두 값이 같은지 비교하는 방식이다.</p>

<p>이 방법을 이용해 <code class="language-plaintext highlighter-rouge">categories</code>배열이 완전히(원소의 순서까지) 같은 경우에만 해당 카테고리에 해당하는 경우로 처리할 수 있다.</p>

<h2 id="3-카테고리-리스트-만들기">3. 카테고리 리스트 만들기.</h2>
<p>카테고리 리스트 또한 사이트 변수등을 이용해서 만들 수 있지만 
필자의 경우 카테고리간 상하관계를 구현하기 복잡해서 직접구현했다.<br />
<code class="language-plaintext highlighter-rouge">/menu/category.html</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;ul class="category-list"&gt;
  &lt;li&gt;
    &lt;a href="http://localhost:4000/category/Oracle.html"&gt;Oracle&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href="http://localhost:4000/category/Tools.html"&gt;Tools&lt;/a&gt;
    &lt;ul&gt;
      &lt;a href="http://localhost:4000/category/Git.html"&gt;Git&lt;/a&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre></div></div>]]></content><author><name>Wonbin Kim</name></author><category term="Jekyll" /><summary type="html"><![CDATA[Jekyll liquid variable을 활용해 Github 블로그에 카테고리 페이지를 추가하는 방법.]]></summary></entry><entry><title type="html">[백준 2842번 집배원 한상덕] JAVA 풀이</title><link href="http://localhost:4000/algorithm/boj/2842.html" rel="alternate" type="text/html" title="[백준 2842번 집배원 한상덕] JAVA 풀이" /><published>2022-03-13T00:00:00+09:00</published><updated>2022-03-13T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/boj/2842</id><content type="html" xml:base="http://localhost:4000/algorithm/boj/2842.html"><![CDATA[<h2 id="문제의-요구사항">문제의 요구사항</h2>
<ul>
  <li><a href="https://www.acmicpc.net/problem/2842">문제 링크</a><br />
P에서 출발해서 모든 K를 방문하고 P로 돌아오는 방법중 가장 적은 피로도로 움직이는 방법을 구하는 문제이다.<br />
이때 주의할점이 있다.
    <ol>
      <li>모든 K를 방문하는것만 구현하면 된다. 같은 길로 돌아가면 되기 때문</li>
      <li>부분 문제의 최적이 전체문제의 최적이 아니다.</li>
    </ol>
  </li>
</ul>

<p>주의할 점 2번을 깨닫는게 좀 어려웠던것 같다.<br />
한상덕의 피로도는 전체 경로중에 가장 높은 고도와 가장 낮은 고도의 차이이며 이를 최소화하는것이 이 문제의 목표이다.</p>

<p>즉, DFS로 한상덕의 마을을 탐색한다고 했을때, 부분적인 경로에서 피로도를 최소화하는것으로는 문제해결이 불가능하다는 것 이다.</p>

<p>따라서 전체 경로에 대한 가장 낮은고도와 가장 높은 고도를 설정해 놓고, 
이 고도사이에서 모든 집을 방문할 수 있는가를 확인하는것이 풀이방법이 될 것 이다.</p>

<h2 id="대략적인-방법">대략적인 방법</h2>
<p><strong>1. 전체 경로의 고도 특정하기</strong><br />
입력을 통해 마을의 모든 부분의 고도를 확인할 수 있는데 이를 중복을 제거하고 오름차순으로 정렬한다.<br />
이 정렬된 고도값들에 두개의 포인터(<code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code> 등)를 사용하여 고도값을 조정한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">고도값개수</span><span class="o">){</span>
    <span class="o">...</span><span class="c1">//left와 right이용해 최대, 최소 고도를 우체국에서 출발하는 dfs에 전달하기</span>
    <span class="k">if</span><span class="o">(</span><span class="n">dfs결과방문한집개수</span> <span class="o">==</span> <span class="n">전체집개수</span><span class="o">){</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">altitute</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">-</span> <span class="n">altitute</span><span class="o">[</span><span class="n">left</span><span class="o">]);</span>
        <span class="n">left</span><span class="o">++;</span>
    <span class="o">}</span><span class="k">else</span> <span class="n">right</span><span class="o">++;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>2. DFS 구현하기</strong><br />
DFS메서드의 인자는 <code class="language-plaintext highlighter-rouge">최대고도</code>, <code class="language-plaintext highlighter-rouge">최소고도</code>, <code class="language-plaintext highlighter-rouge">현재위치</code>를 가지도록 했고, 
리턴값은 해당 부분경로에서 방문한 집의 개수로 했다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">,</span> <span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">){</span>
    <span class="c1">//1. 기저조건(이미 방문했거나 지도의 범위를 벗어난경우 0리턴)</span>

    <span class="c1">//2. 탐색하기(갈 수 있는 부분경로들의 결과값을 모두 합침)</span>

    <span class="c1">//3. 리턴</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="소스코드">소스코드</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">집배원_한상덕</span> <span class="o">{</span>

    <span class="c1">//https://www.acmicpc.net/problem/2842</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="no">N</span><span class="o">][];</span>
        <span class="n">altitute</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>
        <span class="c1">//중복을 제거하기위해 Set사용함</span>
        <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">alts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">h</span><span class="o">++){</span>
            <span class="n">board</span><span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">toCharArray</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">w</span><span class="o">++){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">h</span><span class="o">][</span><span class="n">w</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'P'</span><span class="o">){</span><span class="n">ph</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span> <span class="n">pw</span> <span class="o">=</span> <span class="n">w</span><span class="o">;}</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">h</span><span class="o">][</span><span class="n">w</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'K'</span><span class="o">){</span><span class="no">K</span><span class="o">++;}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">h</span><span class="o">++){</span>
            <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">w</span><span class="o">++){</span>
                <span class="n">altitute</span><span class="o">[</span><span class="n">h</span><span class="o">][</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="n">alts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">altitute</span><span class="o">[</span><span class="n">h</span><span class="o">][</span><span class="n">w</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">find</span><span class="o">(</span><span class="n">alts</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">alts</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1000000</span><span class="o">;</span>

        <span class="nc">Integer</span><span class="o">[]</span> <span class="n">alt</span> <span class="o">=</span> <span class="n">alts</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">alt</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">alt</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">alt</span><span class="o">[</span><span class="n">left</span><span class="o">];</span> <span class="n">high</span> <span class="o">=</span> <span class="n">alt</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
            <span class="n">vis</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">visitedHomes</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">,</span> <span class="n">ph</span><span class="o">,</span> <span class="n">pw</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">visitedHomes</span> <span class="o">==</span> <span class="no">K</span><span class="o">){</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="o">);</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span> <span class="n">right</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">K</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">ph</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">pw</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">altitute</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">alt</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">vis</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">dir</span> <span class="o">=</span> <span class="o">{</span>
        <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>
        <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span>
        <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
        <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>
        <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>
        <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>
        <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
        <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">}</span>
    <span class="o">};</span>
    <span class="c1">//정해진 low, high로 전체 집을 탐색할 수 있는가?</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">,</span> <span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">high</span> <span class="o">&lt;</span> <span class="n">low</span> <span class="o">||</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">h</span> <span class="o">&gt;=</span> <span class="no">N</span> <span class="o">||</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">w</span> <span class="o">&gt;=</span> <span class="no">N</span> <span class="o">||</span> <span class="n">vis</span><span class="o">[</span><span class="n">h</span><span class="o">][</span><span class="n">w</span><span class="o">]</span> <span class="o">||</span> <span class="n">low</span> <span class="o">&gt;</span> <span class="n">altitute</span><span class="o">[</span><span class="n">h</span><span class="o">][</span><span class="n">w</span><span class="o">]</span> <span class="o">||</span> <span class="n">high</span> <span class="o">&lt;</span> <span class="n">altitute</span><span class="o">[</span><span class="n">h</span><span class="o">][</span><span class="n">w</span><span class="o">])</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="n">vis</span><span class="o">[</span><span class="n">h</span><span class="o">][</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">h</span><span class="o">][</span><span class="n">w</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'K'</span><span class="o">)</span> <span class="n">result</span><span class="o">++;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">dir</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">d</span><span class="o">++)</span>   <span class="n">result</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">,</span> <span class="n">h</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="n">d</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">w</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="n">d</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name>Wonbin Kim</name></author><category term="Algorithm" /><category term="BOJ" /><summary type="html"><![CDATA[백준 집배원 한상덕 문제의 JAVA풀이. DFS를 사용한다.]]></summary></entry><entry><title type="html">[백준 1725번 히스토그램] JAVA 풀이</title><link href="http://localhost:4000/algorithm/boj/1725.html" rel="alternate" type="text/html" title="[백준 1725번 히스토그램] JAVA 풀이" /><published>2022-03-11T00:00:00+09:00</published><updated>2022-03-11T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/boj/1725</id><content type="html" xml:base="http://localhost:4000/algorithm/boj/1725.html"><![CDATA[<h2 id="문제-요구사항">문제 요구사항</h2>
<p><a href="https://www.acmicpc.net/problem/1725">문제 링크</a> 
<img src="/assets/img/BOJ/1725histogram.png" alt="문제" /> 
히스토그램에서 밑변과 평행한 가장 큰 직사각형을 그리는것이 문제다.<br />
이때 직사각형의 높이는 히스토그램의 높이보다 높을 수 없으므로 직사각형이 걸쳐있는 여러개의 막대중 가장 작은 막대의 높이와 같을 것 이다.</p>

<p>직사각형이 어떤 형태를 가져야하는지 알았으니 어떻게 가장 큰 직사각형을 판단할지 정해야한다.</p>

<h3 id="직사각형-구하기">직사각형 구하기</h3>
<p>직사각형을 분류하자면 아래의 3가지중 하나이다.</p>
<ol>
  <li>전체 히스토그램의 가운데에 걸쳐있는 경우</li>
  <li>히스토그램의 왼쪽 절반에 위치해 있는경우</li>
  <li>히스토그램의 오른쪽 절반에 위치해 있는경우</li>
</ol>

<p>이러한 분류를 하면 <code class="language-plaintext highlighter-rouge">왼쪽의 직사각형</code>, <code class="language-plaintext highlighter-rouge">오른쪽의 직사각형</code>, <code class="language-plaintext highlighter-rouge">가운데에 걸친 직사각형</code> 3가지를 각각 구한다음 비교하면된다. 이때, 시간복잡도는 <code class="language-plaintext highlighter-rouge">Nlog(N)</code>인데 N이 크지 않으므로 제한시간안에 풀이가 가능하다.</p>

<p>또, 이 분류의 장점은 전체 문제를 작은 문제로 나눌수 있으며 재귀적인 방법으로 구할 수 있다는것이다.<br />
재귀적으로 구할 때 주의할 점은 기저사례를 놓치지 않는것인데 나는 이 문제의 기저사례를 막대 하나에 대해서만 직사각형을 구할때로 적용했다.</p>
<h3 id="소스코드">소스코드</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">히스토그램1725</span> <span class="o">{</span>

    <span class="cm">/**
     * https://www.acmicpc.net/problem/1725
     * 
     * 큰 막대 부터 시작
     */</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="n">histogram</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>  <span class="n">histogram</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">find</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="no">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">histogram</span><span class="o">;</span>

    <span class="cm">/**
     * start부터 end중에 가장 큰 직사각형 구한다.
     */</span>
    <span class="kd">static</span> <span class="kt">long</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="o">)</span> <span class="k">return</span> <span class="n">histogram</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="c1">//왼쪽</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
        <span class="c1">//오른쪽</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">find</span><span class="o">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">));</span>

        <span class="c1">//중간에 걸친(큰 막대에서부터 구하기)</span>
        <span class="k">if</span><span class="o">(</span><span class="n">histogram</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">histogram</span><span class="o">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="n">mid</span><span class="o">++;</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span> <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">min</span> <span class="o">=</span> <span class="n">histogram</span><span class="o">[</span><span class="n">mid</span><span class="o">];</span><span class="c1">//막대중 최소 높이</span>
        <span class="k">while</span><span class="o">(</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">e</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">){</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">min</span> <span class="o">*</span> <span class="o">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
            <span class="k">if</span><span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">s</span> <span class="o">==</span> <span class="n">start</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">end</span><span class="o">){</span><span class="n">s</span><span class="o">--;</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">histogram</span><span class="o">[</span><span class="n">s</span><span class="o">]);</span><span class="k">continue</span><span class="o">;}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">start</span><span class="o">){</span><span class="n">e</span><span class="o">++;</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">histogram</span><span class="o">[</span><span class="n">e</span><span class="o">]);</span><span class="k">continue</span><span class="o">;}</span>

            <span class="c1">//왼쪽, 오른쪽중 더 큰 막대의 방향으로 이동</span>
            <span class="k">if</span><span class="o">(</span><span class="n">histogram</span><span class="o">[</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">histogram</span><span class="o">[</span><span class="n">e</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]){</span><span class="n">e</span><span class="o">++;</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">histogram</span><span class="o">[</span><span class="n">e</span><span class="o">]);}</span>
            <span class="k">else</span><span class="o">{</span><span class="n">s</span><span class="o">--;</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">histogram</span><span class="o">[</span><span class="n">s</span><span class="o">]);}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Wonbin Kim</name></author><category term="Algorithm" /><category term="BOJ" /><summary type="html"><![CDATA[문제 요구사항 문제 링크 히스토그램에서 밑변과 평행한 가장 큰 직사각형을 그리는것이 문제다. 이때 직사각형의 높이는 히스토그램의 높이보다 높을 수 없으므로 직사각형이 걸쳐있는 여러개의 막대중 가장 작은 막대의 높이와 같을 것 이다. 직사각형이 어떤 형태를 가져야하는지 알았으니 어떻게 가장 큰 직사각형을 판단할지 정해야한다.]]></summary></entry><entry><title type="html">[Java] Iterator 사용법, 구현</title><link href="http://localhost:4000/java/java-Iterator.html" rel="alternate" type="text/html" title="[Java] Iterator 사용법, 구현" /><published>2021-10-03T00:00:00+09:00</published><updated>2021-10-03T00:00:00+09:00</updated><id>http://localhost:4000/java/java-Iterator</id><content type="html" xml:base="http://localhost:4000/java/java-Iterator.html"><![CDATA[<ol>
  <li>Iterator의 의미</li>
  <li>Iterator 사용법</li>
  <li>Iterator 만들어보기</li>
</ol>

<h2 id="iterator의-의미">Iterator의 의미</h2>
<p>java.util.Iterator는 자료구조의 요소에 접근하는 일관적 방법을 제공하기 위해 만들어진 인터페이스이다.<br />
따라서 Collection을 상속하는 모든 자료구조들은 <code class="language-plaintext highlighter-rouge">iterator()</code>함수를 통해 해당 객체에 대한 Iterator를 반환하도록 작성되어있다.</p>

<p>이때 Map은 Key와 Value가 따로 있기 때문에 각각에 대한 Collection을 구한 뒤 Iterator를 구해야한다.</p>

<h1 id="iterator-사용법">Iterator 사용법</h1>
<p>Iterator는 3가지 함수를 제공한다.</p>
<ul>
  <li>boolean hasNext(): Collection에 더 읽을 원소가 있는지 확인</li>
  <li>E next(): 다음원소를 읽어 반환</li>
  <li>remove(): next()로 참조한 원소를 삭제.</li>
</ul>

<h1 id="iterator-만들어보기">Iterator 만들어보기</h1>
<p>Collection.iterator()을 구현해 보았다.<br />
익명클래스를 이용하여 Iterator객체를 만든다음 각 함수를 구현해주면 된다.</p>

<script src="https://gist.github.com/rst0070/9d00771a185e69703a25f318d0babad6.js"></script>]]></content><author><name>Wonbin Kim</name></author><category term="Java" /><summary type="html"><![CDATA[Java Iterator의 사용법과 이를 이해하기위해 직접 구현을 해보자]]></summary></entry><entry><title type="html">[Java] Enum, 열거형이란? 실체를 구현해보자</title><link href="http://localhost:4000/java/java-enums.html" rel="alternate" type="text/html" title="[Java] Enum, 열거형이란? 실체를 구현해보자" /><published>2021-10-03T00:00:00+09:00</published><updated>2021-10-03T00:00:00+09:00</updated><id>http://localhost:4000/java/java-enums</id><content type="html" xml:base="http://localhost:4000/java/java-enums.html"><![CDATA[<h3 id="목차">목차</h3>
<ol>
  <li>Enum의 의미</li>
  <li>Enum 선언 및 사용 방법</li>
  <li>Enum의 실체</li>
  <li>Enum 구현해보기</li>
</ol>

<h2 id="1-enum의-의미">1. Enum의 의미</h2>
<p>Enum은 열거형 이라는 의미이며 일반적으로 관련된 상수를 묶어주는 역할을 한다.<br />
Java의 열거형은 위 특징에 추가되는 ‘타입 체크’기능이있으므로 
크게 아래 두가지의 역할을 한다고 할 수 있다.</p>

<ol>
  <li>비슷한 상수들을 타입으로 묶는 기능</li>
  <li>묶인 타입별로 구분하는 기능.</li>
</ol>

<p>이외에도 정의된 순서를 구하거나 이름을 구하는등 기능이 있지만 위 두가지 기능만 보겠다.</p>

<h2 id="2-enum선언하기-사용하기">2. Enum선언하기, 사용하기</h2>

<h3 id="21-타입구분-기능">2.1 타입구분 기능.</h3>
<p>enum은 아래와 같이 선언하고 사용하며, 값이 같더라도 타입이 다르면 다른 상수로 인식한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="nc">Color1</span> <span class="o">{</span> <span class="no">RED</span><span class="o">,</span> <span class="o">...}</span>
<span class="kd">enum</span> <span class="nc">Color2</span> <span class="o">{</span> <span class="no">RED</span><span class="o">,</span> <span class="o">...}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Color1</span><span class="o">.</span><span class="na">RED</span> <span class="o">==</span> <span class="nc">Color2</span><span class="o">.</span><span class="na">RED</span><span class="o">);</span><span class="c1">// =&gt; false</span>
</code></pre></div></div>
<h3 id="22-각-enum에-생성자-부여하기">2.2 각 enum에 생성자 부여하기</h3>
<p>각 enum이 값을 가지게 할 수 있는데 이때는 생성자가 필요하다.<br />
이때 생성자는 자동적으로 private만 가능하게 되어 외부에서 사용할 수 없다.</p>

<p>생성자 뿐만아니라 다른 메소드, 변수등도 내부적으로 선언할 수 있어 각 enum이 지니게 할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="nc">Color</span><span class="o">{</span>
    <span class="no">RED</span><span class="o">(</span><span class="s">"red"</span><span class="o">),</span> <span class="no">GREEN</span><span class="o">(</span><span class="s">"green"</span><span class="o">),</span> <span class="no">BLUE</span><span class="o">(</span><span class="s">"blue"</span><span class="o">);</span>

    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    
    <span class="nc">Color</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="nc">String</span> <span class="nf">getName</span><span class="o">(){</span><span class="k">return</span> <span class="n">name</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="3-enum의-실체-및-구현하기">3. Enum의 실체 및 구현하기</h2>
<p>앞의 내용을 보면 enum의 정체가 무엇이길래 생성자등을 가질 수 있는지 의문이 생길 것 이다.<br />
enum에 대한 사실을 나열해보면</p>
<ol>
  <li>모든 enum은 java.lang.Enum을 상속받는다.</li>
  <li>따라서 모든 열거형은 객체이다.</li>
  <li>타입클래스는 자신의 열거형 객체들을 static final 로 참조하고있다.</li>
</ol>

<p>위의 특징들을 통해 java enum은 임의로 값을 지정할 수 있으며 타입체크가 가능한 것 이다. 
따라서 Enum은 아래의 클래스와 같은 동작을 하는것이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Color</span><span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Color</span> <span class="no">RED</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Color</span><span class="o">(</span><span class="s">"red"</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Color</span> <span class="no">GREEN</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Color</span><span class="o">(</span><span class="s">"green"</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Color</span> <span class="no">BLUE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Color</span><span class="o">(</span><span class="s">"blue"</span><span class="o">);</span>

    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nf">Color</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>물론 실제 Enum의 기능을 훨씬 축소시키고 상속도 구현하지 않았지만 
Enum이 어떤 방식으로 가능한 것인지 구현해보았다.</p>]]></content><author><name>Wonbin Kim</name></author><category term="Java" /><summary type="html"><![CDATA[Java enum 열거형이 무엇인지 알아보고 실체를 구현해보자]]></summary></entry><entry><title type="html">컨테이너 배포란? : 애플리케이션 배포의 역사</title><link href="http://localhost:4000/etc/what-is-container-deployment.html" rel="alternate" type="text/html" title="컨테이너 배포란? : 애플리케이션 배포의 역사" /><published>2021-04-03T00:00:00+09:00</published><updated>2021-04-03T00:00:00+09:00</updated><id>http://localhost:4000/etc/what-is-container-deployment</id><content type="html" xml:base="http://localhost:4000/etc/what-is-container-deployment.html"><![CDATA[<p>컨테이너 형태의 배포는 애플리케이션 배포 패러다임중 하나이다. 이를 이해하기위해 역사를 살펴보자.</p>

<p><img src="https://d33wubrfki0l68.cloudfront.net/26a177ede4d7b032362289c6fccd448fc4a91174/eb693/images/docs/container_evolution.svg" alt="history" /></p>
<ol>
  <li>전통적 배포
  하나의 서버위에서 여러 애플리케이션을 실행하게되면 서버 자원을 각 애플리케이션에 어떻게 분배할지 문제가 발생한다(자원이 부족한 애플리케이션이 생긴다).<br />
  이런 문제를 피하기위해 하나의 서버에 하나의 애플리케이션이 동작하도록 배포하는게 전통적 배포이다.</li>
  <li>가상화 배포
  전통적 배포의 문제점은 자원낭비가 심하다는것이다.<br />
  이를 해결하기 위해 가상화 배포는 Hypervisor와 Virtual Machine을 이용해 하나의 서버위에 여러 애플리케이션이 실행될 수 있게 된다.
    <ul>
      <li>하이퍼바이저와 가상머신의 동작
 가상머신은 하나의 머신으로서 운영체재를 포함한다. 이 가상머신들을 물리적인 서버에서 동작시키는것이 하이퍼바이저이다.<br />
 하이퍼바이저는 각 가상머신에게 서버의 리소스를 분배하고 가상머신들을 격리하는 역할을 한다.</li>
    </ul>
  </li>
  <li>컨테이너 배포
  컨테이너 배포는 가상화 배포에서 격리의 강도를 줄여 각 애플리케이션이 os를 공유한다고 생각하면 된다. 
  하나의 서버위에 여러 컨테이너를 실행시키기 위해 VM과 마찬가지로 각 컨테이너에 대한 자원 할당이 정해져 있다. 
  이식성이 좋아 여러 환경에 대해 배포가 쉽고 VM에 비해 이미지 생성이 쉽다.</li>
</ol>]]></content><author><name>Wonbin Kim</name></author><category term="Etc" /><summary type="html"><![CDATA[컨테이너 형태의 배포는 애플리케이션 배포 패러다임중 하나이다. 이를 이해하기위해 역사를 살펴보자.]]></summary></entry><entry><title type="html">[Javascript] Hoisting과 변수의 유효범위 이해하기: 자바스크립트가 변수를 해석하는 방법</title><link href="http://localhost:4000/javascript/hoisting-and-scope.html" rel="alternate" type="text/html" title="[Javascript] Hoisting과 변수의 유효범위 이해하기: 자바스크립트가 변수를 해석하는 방법" /><published>2021-03-26T00:00:00+09:00</published><updated>2021-03-26T00:00:00+09:00</updated><id>http://localhost:4000/javascript/hoisting-and-scope</id><content type="html" xml:base="http://localhost:4000/javascript/hoisting-and-scope.html"><![CDATA[<p>이 글에서는 <code class="language-plaintext highlighter-rouge">Hoisting</code>과 <code class="language-plaintext highlighter-rouge">변수의 유효범위</code>를 이해함으로써 자바스크립트가 어떻게 변수를 찾는지 알아볼 것이다.</p>

<h1 id="1-자바스크립트-함수단위-변수유효범위">1. 자바스크립트: 함수단위 변수유효범위</h1>
<p>변수의 유효범위란 어떤 변수가 유효한 범위를 의미함을 생각하면서 아래의 코드들을 보자.</p>

<p>먼저 c로 작성된 다음의 코드를 보자.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>이 코드는 블록안에있는 변수를 참조하니 당연히 작동되지 않는다.</p>

<p>하지만 아래의 javascript 코드는 정상적으로 작동한다.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">main</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">number</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">main</span><span class="p">();</span>
</code></pre></div></div>

<p>왜 이런 차이가 발생할까?<br />
앞서 언급했듯 변수의 유효범위의 차이에 답이 있다.
C언어는 블록단위 유효범위를 사용한다. 즉 중괄호’{}’로 감싸져 있는것으로 변수의 유효범위가 달라진다는것이다.</p>

<p>하지만 javascript는 <code class="language-plaintext highlighter-rouge">함수 유효범위</code>를 사용한다. 즉 블록이 기준이 아니라 함수로 구분한다는 것이다.<br />
따라서 함수내부에서 중첩함수안에 있는 변수만 접근하지 못한다는 것이다.</p>

<h1 id="2-javascript는-변수를-hoisting한다">2. javascript는 변수를 Hoisting한다.</h1>
<p>Hoisting은 끌어올린다는 의미이다. 즉 변수를 끌어올린다는 것. 
아까 예시를 조금 변형해보면..</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">main</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">number</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">}</span>
<span class="nx">main</span><span class="p">();</span>
</code></pre></div></div>
<p>위 코드는 오류가 발생할 것 같지만 <code class="language-plaintext highlighter-rouge">undefined</code>를 출력한다.<br />
즉 변수 <code class="language-plaintext highlighter-rouge">number</code>가 10으로 정의되기전에 이미 <code class="language-plaintext highlighter-rouge">number</code>는 존재하던 것이다.</p>

<p>위 예시에서 확인할 수 있는것은 javascript가 변수의 선언을 함수의 상단 혹은 코드의 상단으로 hoisting한다는 것이다.
따라서 위의 코드는 다음과 같다.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">main</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">number</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">number</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">){</span>
        <span class="nx">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">}</span>
<span class="nx">main</span><span class="p">();</span>
</code></pre></div></div>
<p>hoisting이라는 특징을 코드에 반영하는 방법중 하나는 변수의 선언을 코드의 상단에 작성하는것이다.<br />
이를 통해 프로그램의 동작을 명확히 할 수 있다.</p>

<h1 id="3-변수-해석하기-유효범위-체인을-찾는다">3. 변수 해석하기: 유효범위 체인을 찾는다.</h1>
<p>변수의 값을 가져오고 수정하는등의 코드를 실행할때 어떻게 해당 변수를 찾는것 일까? 이 과정이 바로 변수해석(variable resolution)이다.</p>

<p>어떤 코드에 대해 변수유효범위를 나타내는 객체가 존재한다. 
이 객체들은 자신의 프로퍼티로 해당 변수들(유효범위에 있는 변수들)을 가지고 있는다.</p>

<p>예를들어 전역객체는 전역변수들을 프로퍼티로 가지고 있으며, 함수의 지역변수나 매개변수를 프로퍼티로 가지는 객체도 존재한다.</p>

<p>위의 객체들을 포함한 리스트를 <code class="language-plaintext highlighter-rouge">유효범위 체인</code>이라고 부르며, 
변수해석과정은 이 리스트에서 원하는 변수를 찾는것 이다.</p>

<p>함수의 경우 함수가 정의될때 유효범위체인이 최초로 저장되는데 이때는 전역객체 및 상위 함수의 유효범위 체인이 저장된다. 
이후 함수가 실행될때는 지역변수 및 매개변수에 대한 유효범위 객체가 추가되어 저장된다.</p>

<p>이를 응용하여 3가지 경우에 대해 유효범위 체인이 어떻게 생성되는지 생각해 볼 수 있다.</p>
<ol>
  <li>전역코드: 전역객체만이 유효범위 체인에 포함된다.</li>
  <li>일반적 함수내부: 전역객체, 지역변수 및 매개변수를 가지는 객체</li>
  <li>중첩된함수: 상위함수의 유효범위체인 및 자신의 지역변수 및 매개변수를 가지는 객체.</li>
</ol>

<h1 id="4-정리">4. 정리</h1>
<p>javascript에서는…</p>
<ol>
  <li>변수의 유효범위가 함수 단위로 나뉘게 된다.</li>
  <li>변수의 선언은 맨위로 끌어올려진다.</li>
  <li>변수는 유효범위체인을 통해 찾아진다.</li>
</ol>]]></content><author><name>Wonbin Kim</name></author><category term="Javascript" /><summary type="html"><![CDATA[이 글에서는 Hoisting과 변수의 유효범위를 이해함으로써 자바스크립트가 어떻게 변수를 찾는지 알아볼 것이다.]]></summary></entry><entry><title type="html">css 가상요소: after , before 요소 위치지정하기</title><link href="http://localhost:4000/frontend/css-pseudo-element-positioning.html" rel="alternate" type="text/html" title="css 가상요소: after , before 요소 위치지정하기" /><published>2021-02-26T00:00:00+09:00</published><updated>2021-02-26T00:00:00+09:00</updated><id>http://localhost:4000/frontend/css-pseudo-element-positioning</id><content type="html" xml:base="http://localhost:4000/frontend/css-pseudo-element-positioning.html"><![CDATA[<p>가상선택자 after, before 엘리먼트가 사라지는 현상을 해결하고 그 방법을 작성한 글이다. after, before 엘리먼트의 위치지정 방법을 정리했다.</p>

<p>결론 부터 말하자면 아래와 같다.</p>
<ol>
  <li>위치를 지정하기 위해서는 대상 엘리먼트, after, before 모두의 스타일이 <code class="language-plaintext highlighter-rouge">position: absolute</code>여야 한다.</li>
  <li>after, before 가상요소는 <code class="language-plaintext highlighter-rouge">content</code>속성이 지정되어야한다.</li>
  <li>after, before는 그 기준인 엘리먼트를 기준으로 위치가 지정된다.</li>
  <li>위치 지정시 <code class="language-plaintext highlighter-rouge">top</code>, <code class="language-plaintext highlighter-rouge">left</code>와 <code class="language-plaintext highlighter-rouge">transform: translate()</code>는 같은 효과를 가진다.</li>
</ol>

<p>이제 하나씩 설명하겠다.</p>
<h1 id="1-대상-엘리먼트와-after-before-엘리먼트는-position-absolute여야-한다">1. 대상 엘리먼트와 after, before 엘리먼트는 <code class="language-plaintext highlighter-rouge">position: absolute;</code>여야 한다.</h1>
<p>위의 전제조건이 있어야 다음단계(위치지정)로 넘어갈 수 있다.<br />
앞으로 사용할 코드이다.</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>----------html----------
<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"parent"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"base"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
----------css-----------
#base { position: absolute;}
#base::before, #base::after {position: absolute;}
</code></pre></div></div>

<h1 id="2-after-before-가상요소는-content속성이-지정되어야한다">2. after, before 가상요소는 <code class="language-plaintext highlighter-rouge">content</code>속성이 지정되어야한다.</h1>
<p>1번과 마찬가지로 전제조건이다. 즉 after와 before에<code class="language-plaintext highlighter-rouge">content:""</code> 라도 명시해줘야한다.</p>

<h1 id="3-가상요소after-before는-대상엘리먼트를-기준으로-위치가-지정된다">3. 가상요소(after, before)는 대상엘리먼트를 기준으로 위치가 지정된다.</h1>
<p>즉 코드에서 <code class="language-plaintext highlighter-rouge">#base::after</code>와 <code class="language-plaintext highlighter-rouge">#base::before</code>요소는 <code class="language-plaintext highlighter-rouge">#parent</code>가 아닌 <code class="language-plaintext highlighter-rouge">#base</code>를 기준으로 위치가 지정된다.</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"parent"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"base"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
-----------css-------
#base { position: absolute;}
#base::before {
    position: absolute;
    top: 20px;
}
</code></pre></div></div>
<p>따라서 위처럼 스타일을 지정하면 <code class="language-plaintext highlighter-rouge">#base::before</code>는 <code class="language-plaintext highlighter-rouge">#base</code>로 부터 20px 아래에 위치한다.</p>

<h1 id="3-가상요소after-before에서-top-left는-traslate와-같은-효과이다">3. 가상요소(after, before)에서 top, left는 traslate와 같은 효과이다.</h1>
<p>즉 위에서 언급한 가상요소의 스타일 <code class="language-plaintext highlighter-rouge">top: 20px; left:30px</code>는 <code class="language-plaintext highlighter-rouge">transform: translate(20px, 30px);</code>와 같다.</p>]]></content><author><name>Wonbin Kim</name></author><category term="FrontEnd" /><summary type="html"><![CDATA[가상선택자 after, before 엘리먼트가 사라지는 현상을 해결하고 그 방법을 작성한 글이다. after, before 엘리먼트의 위치지정 방법을 정리했다. 결론 부터 말하자면 아래와 같다. 위치를 지정하기 위해서는 대상 엘리먼트, after, before 모두의 스타일이 position: absolute여야 한다. after, before 가상요소는 content속성이 지정되어야한다. after, before는 그 기준인 엘리먼트를 기준으로 위치가 지정된다. 위치 지정시 top, left와 transform: translate()는 같은 효과를 가진다. 이제 하나씩 설명하겠다. 1. 대상 엘리먼트와 after, before 엘리먼트는 position: absolute;여야 한다. 위의 전제조건이 있어야 다음단계(위치지정)로 넘어갈 수 있다. 앞으로 사용할 코드이다. ----------html---------- &lt;div id="parent"&gt; &lt;div id="base"&gt;&lt;/div&gt; &lt;/div&gt; ----------css----------- #base { position: absolute;} #base::before, #base::after {position: absolute;} 2. after, before 가상요소는 content속성이 지정되어야한다. 1번과 마찬가지로 전제조건이다. 즉 after와 before에content:"" 라도 명시해줘야한다.]]></summary></entry><entry><title type="html">[Node.js] http request 보내기</title><link href="http://localhost:4000/javascript/http-request.html" rel="alternate" type="text/html" title="[Node.js] http request 보내기" /><published>2021-02-26T00:00:00+09:00</published><updated>2021-02-26T00:00:00+09:00</updated><id>http://localhost:4000/javascript/http-request</id><content type="html" xml:base="http://localhost:4000/javascript/http-request.html"><![CDATA[<h2 id="개요">개요</h2>
<p>node.js 에 기본 탑재되어있는 http 모듈을 이용해 http.ClientRequest 객체를 생성하고 데이터를 붙여 전송하는 방법을 다룹니다.</p>
<ol>
  <li><a href="#stepA">request 생성하기</a></li>
  <li><a href="#stepB">데이터 및 request 전송</a></li>
  <li><a href="#stepC">response 처리</a></li>
</ol>

<p><a href="https://nodejs.org/dist/latest-v14.x/docs/api/http.html">node.js 문서</a>를 참고하며 작성했습니다.</p>

<h2 id="1-clientrequest-생성"><a name="stepA">1. ClientRequest 생성</a></h2>
<p><code class="language-plaintext highlighter-rouge">http.request(url[,options][,callback])</code>과 <code class="language-plaintext highlighter-rouge">http.request(options[,callback])</code>함수의 반환값을 통해 생성할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">option</code>파라미터는 헤더, request방식등을 담고 있는 객체이며<br />
<code class="language-plaintext highlighter-rouge">callback</code>은 해당 request에 대한 서버의 응답(response 이벤트 호출시)시 호출되는 함수입니다.</p>

<p>post요청 예시</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{...}</span>
<span class="kd">const</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/x-www-form-urlencoded;charset=utf-8</span><span class="dl">'</span><span class="p">,</span>
        <span class="dl">'</span><span class="s1">Content-Length</span><span class="dl">'</span><span class="p">:</span> <span class="nx">Buffer</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">req</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://example.com</span><span class="dl">"</span><span class="p">,</span> <span class="nx">options</span><span class="p">,</span> <span class="p">()</span><span class="o">=&gt;</span><span class="p">{});</span>
</code></pre></div></div>
<h2 id="2-데이터를-붙여-전송하기"><a name="stepB">2. 데이터를 붙여 전송하기</a></h2>
<p><code class="language-plaintext highlighter-rouge">ClientRequest.end([data[,encoding]][,callback])</code>를 통해 전송가능합니다.</p>

<p>파라미터인 <code class="language-plaintext highlighter-rouge">data</code>는 문자열이고 <code class="language-plaintext highlighter-rouge">callback</code>은 전송이 끝났을때 호출되는 함수 입니다.</p>

<p><code class="language-plaintext highlighter-rouge">ClientRequest.end()</code>에 문자열화 된 data를 넣어 실행 시키면 테이터를 붙여 전송하게 됩니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
    <span class="na">data</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/x-www-form-urlencoded;charset=utf-8</span><span class="dl">'</span><span class="p">,</span>
        <span class="dl">'</span><span class="s1">Content-Length</span><span class="dl">'</span><span class="p">:</span> <span class="nx">Buffer</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">req</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://example.com</span><span class="dl">"</span><span class="p">,</span> <span class="nx">options</span><span class="p">,</span> <span class="p">(</span><span class="nx">res</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{});</span>

<span class="nx">req</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="3-response-받기"><a name="stepC">3. response 받기</a></h2>
<p><a href="stepA">앞에서</a>설명했듯이 <code class="language-plaintext highlighter-rouge">http.request()</code>의 마지막 파라미터를 통해 response 이벤트 발생시 객체를 얻을 수 있습니다.<br />
이때 객체는 `http.IncomingMessage’클래스의 인스턴스입니다.<br />
자세한 내용은 <a href="https://nodejs.org/dist/latest-v14.x/docs/api/http.html#http_class_http_incomingmessage">api 참조</a></p>

<p>이 객체를 통해서 서버로부터 받은 데이터를 확인할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
    <span class="na">data</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/x-www-form-urlencoded;charset=utf-8</span><span class="dl">'</span><span class="p">,</span>
        <span class="dl">'</span><span class="s1">Content-Length</span><span class="dl">'</span><span class="p">:</span> <span class="nx">Buffer</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">req</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://example.com</span><span class="dl">"</span><span class="p">,</span> <span class="nx">options</span><span class="p">,</span>
    <span class="p">(</span><span class="nx">res</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">mydata</span><span class="p">);</span>
    <span class="p">});</span>

<span class="nx">req</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</code></pre></div></div>]]></content><author><name>Wonbin Kim</name></author><category term="[&quot;Javascript&quot;]" /><summary type="html"><![CDATA[개요 node.js 에 기본 탑재되어있는 http 모듈을 이용해 http.ClientRequest 객체를 생성하고 데이터를 붙여 전송하는 방법을 다룹니다. request 생성하기 데이터 및 request 전송 response 처리 node.js 문서를 참고하며 작성했습니다.]]></summary></entry><entry><title type="html">ssh key 생성, port변경, 접속하기</title><link href="http://localhost:4000/tools/using-ssh.html" rel="alternate" type="text/html" title="ssh key 생성, port변경, 접속하기" /><published>2021-02-19T00:00:00+09:00</published><updated>2021-02-19T00:00:00+09:00</updated><id>http://localhost:4000/tools/using-ssh</id><content type="html" xml:base="http://localhost:4000/tools/using-ssh.html"><![CDATA[<h2 id="ssh-개요">ssh 개요</h2>
<p>ssh는 ssh-server와 ssh-client간의 통신을 통해 client에서 server로 원격접속을 통해 server의 시스템 조작을 가능하게 해주는 도구이다.<br />
공개키-비공기키 방식을 통해 간편하고 안전한 접속을 가능하게 해준다.</p>

<h2 id="서버설정-및-실행-방법리눅스-기준">서버설정 및 실행 방법(리눅스 기준)</h2>
<p>서버에는 openssh-server를 설치해주면 된다.
설치 후 <code class="language-plaintext highlighter-rouge">service ssh start</code> 명령을 통해 서버를 실행 시키면 된다.</p>

<h2 id="클라이언트-설정-및-접속-방법">클라이언트 설정 및 접속 방법</h2>
<p>설치해야할 프로그램은 openssh-client이다.<br />
설치 후 <code class="language-plaintext highlighter-rouge">ssh 유저아이디@서버주소</code> 명령을 통해 접속한다.
(이때 ssh의 기본 포트인 22번으로 접속하게 된다.)</p>

<p>접속을 해보면 패스워드를 물을 것이다. 이를 입력하면 접속하게 되는데 패스워드 입력없이 키를 이용한 방법은 아래에 작성해 놓았다.</p>

<h2 id="ssh-서버의-포트를-바꾸는-방법">ssh 서버의 포트를 바꾸는 방법</h2>
<p>서버에 있는 설정파일을 수정해야한다.<br />
<code class="language-plaintext highlighter-rouge">/etc/ssh/sshd_config</code>파일을 수정한다.<br />
파일의 내용을 보다보면 <code class="language-plaintext highlighter-rouge">#Port 22</code>라는 행이 있을것이다.<br />
예를 들어 128번 포트로 변경하고 싶다면 이 행의 밑에 <code class="language-plaintext highlighter-rouge">Port 128</code>을 행 추가 해주자.<br />
클라이언트에서 접속할 때는 <code class="language-plaintext highlighter-rouge">ssh -p 128 유저아이디@서버주소</code>방식으로 접속하면 된다.</p>

<h2 id="key를-사용한-접속-개요">key를 사용한 접속 개요</h2>
<p>공개키와 비공개키를 이용해 ssh접속을 만들어 낼 수 있다.</p>
<ol>
  <li>클라이언트에서 공개키와 비공개키 생성</li>
  <li>서버의 키 목록에 클라이언트의 공개키 추가</li>
  <li>클라이언트에서 서버로 접속</li>
</ol>

<h3 id="1-key-생성하기-클라이언트에서리눅스-기준">1. Key 생성하기: 클라이언트에서(리눅스 기준)</h3>
<p>클라이언트에서 <code class="language-plaintext highlighter-rouge">ssh-keygen</code>을 실행하면 /home/userid/.ssh/ 폴더에 id_rsa와 id_rsa.pub 가 생긴다. 이때 전자가 비공개키, 후자가 공개키이다. 
아래의 명령을 통해 공개키를 서버로 복사하자.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#server의 유저와 주소를 sshserver라고 가정함.
scp /home/userid/.ssh/id_rsa.pub sshserver@sshserver:/home/sshserver
</code></pre></div></div>

<h3 id="2-서버의-키-목록에-공개키-추가">2. 서버의 키 목록에 공개키 추가</h3>
<p>옮겨받은 공개키의 내용을 서버의 /home/userid/.ssh/authorized_keys 파일에 추가하면 된다.<br />
userid가 sshserver라고 가정하면 아래의 명령어를 유용하게 사용할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /home/sshserver/id_rsa.pub &gt;&gt; /home/sshserver/.ssh/authorized_keys
# &gt;&gt;을 사용해 cat 명령어의 출력을 다른곳으로 내보낸다.(파일에 추가시킴)
</code></pre></div></div>
<h3 id="3-접속">3. 접속:</h3>
<p>확인해 보면 된다.<br />
추가로 ssh client에 여러개의 비공개키중 하나를 골라 사용하는 명령이 있다.(ssh 연결관계는 여러개가 될 수 있으므로)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh -i [비공개키 경로] ...
</code></pre></div></div>]]></content><author><name>Wonbin Kim</name></author><category term="Tools" /><summary type="html"><![CDATA[ssh 개요 ssh는 ssh-server와 ssh-client간의 통신을 통해 client에서 server로 원격접속을 통해 server의 시스템 조작을 가능하게 해주는 도구이다. 공개키-비공기키 방식을 통해 간편하고 안전한 접속을 가능하게 해준다.]]></summary></entry></feed>