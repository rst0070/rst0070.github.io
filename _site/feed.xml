<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-03-26T00:40:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Rst</title><subtitle></subtitle><author><name>Wonbin Kim</name></author><entry><title type="html">CSS position: 기본위치, 상대위치, 절대위치, 고정위치</title><link href="http://localhost:4000/css-position-relative-absolute-fixed.html" rel="alternate" type="text/html" title="CSS position: 기본위치, 상대위치, 절대위치, 고정위치" /><published>2020-03-25T00:00:00+09:00</published><updated>2020-03-25T00:00:00+09:00</updated><id>http://localhost:4000/css-position-relative-absolute-fixed</id><content type="html" xml:base="http://localhost:4000/css-position-relative-absolute-fixed.html">&lt;p&gt;css의 &lt;code class=&quot;highlighter-rouge&quot;&gt;position&lt;/code&gt;속성에는 &lt;em&gt;static&lt;/em&gt;, &lt;em&gt;relative&lt;/em&gt;, &lt;em&gt;absolute&lt;/em&gt;, &lt;em&gt;fixed&lt;/em&gt;가 
있습니다.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;static&quot;&gt;static&lt;/h2&gt;
&lt;p&gt;static은 모든 요소에 기본적으로 설정된 값입니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;relative&quot;&gt;relative&lt;/h2&gt;
&lt;p&gt;relative 속성은 두가지 특징이 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;relative 속성을 가진 요소가 원래 있던 공간을 다른 요소가 침범하지 못한다.&lt;/li&gt;
  &lt;li&gt;relative 속성을 가진 요소가 자신의 원래 위치를 기준으로 움직인다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;예시&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;.example&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 예시의 경우 &lt;em&gt;.example&lt;/em&gt;은 원래자신의 위치중 오른쪽 위 꼭짓점을 기준으로 
아래로 5px, 왼쪽으로 4px 이동합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;absolute&quot;&gt;absolute&lt;/h2&gt;
&lt;p&gt;절대위치로 설정된 절대요소는 다음과 같은 속성을 갖게 됩니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;static 위치설정이 아닌 부모요소중 가장 가까운 부모를 기준으로 위치를 설정한다.&lt;/li&gt;
  &lt;li&gt;절대요소 자신이 원래 위치해 있던 공간에 다른 요소가 침범할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;예시&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;.example&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;absolute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;fixed&quot;&gt;fixed&lt;/h2&gt;
&lt;p&gt;고정위치로 설정된 고정요소들은 다음과 같은 속성을 갖게 됩니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;고정요소 자신이 원래 위치하던 공간에 다른 요소가 침범할 수 있다.&lt;/li&gt;
  &lt;li&gt;웹브라우저 화변을 기준으로 위치를 이동하며, 스크롤해도 고정되어있다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Wonbin Kim</name></author><category term="css" /><summary type="html">css의 position속성에는 static, relative, absolute, fixed가 있습니다. static static은 모든 요소에 기본적으로 설정된 값입니다. relative relative 속성은 두가지 특징이 있습니다. relative 속성을 가진 요소가 원래 있던 공간을 다른 요소가 침범하지 못한다. relative 속성을 가진 요소가 자신의 원래 위치를 기준으로 움직인다. 예시 .example { position: relative; top: 5px; right: 4px; } 위의 예시의 경우 .example은 원래자신의 위치중 오른쪽 위 꼭짓점을 기준으로 아래로 5px, 왼쪽으로 4px 이동합니다. absolute 절대위치로 설정된 절대요소는 다음과 같은 속성을 갖게 됩니다. static 위치설정이 아닌 부모요소중 가장 가까운 부모를 기준으로 위치를 설정한다. 절대요소 자신이 원래 위치해 있던 공간에 다른 요소가 침범할 수 있다. 예시 .example { position: absolute; top: 5px; right: 5px; } fixed 고정위치로 설정된 고정요소들은 다음과 같은 속성을 갖게 됩니다. 고정요소 자신이 원래 위치하던 공간에 다른 요소가 침범할 수 있다. 웹브라우저 화변을 기준으로 위치를 이동하며, 스크롤해도 고정되어있다.</summary></entry><entry><title type="html">CSS font 속성들과 속기형 작성법</title><link href="http://localhost:4000/css-shorthand-font-set.html" rel="alternate" type="text/html" title="CSS font 속성들과 속기형 작성법" /><published>2020-03-25T00:00:00+09:00</published><updated>2020-03-25T00:00:00+09:00</updated><id>http://localhost:4000/css-shorthand-font-set</id><content type="html" xml:base="http://localhost:4000/css-shorthand-font-set.html">&lt;p&gt;CSS에서 font의 특성을 지정하는 속성들과 이를 빠르게 작성할 수 있는 
속기형 작성법에 대해 포스팅하려 한다.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;css에서-글자-스타일을-지정하는-속성들&quot;&gt;CSS에서 글자 스타일을 지정하는 속성들&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;글꼴: font-family&lt;/li&gt;
  &lt;li&gt;크기: font-size&lt;/li&gt;
  &lt;li&gt;행간: line-height&lt;/li&gt;
  &lt;li&gt;기울기: font-style&lt;/li&gt;
  &lt;li&gt;두께: font-weight&lt;/li&gt;
  &lt;li&gt;음절 앞 글자 대문자: font-variant(영문 글꼴에만 적용)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;예시&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;font-family&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&quot;Times New Roman&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;line-height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;font-style&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;italic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;font-weight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;bold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;font-variant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;small-caps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;예시 처럼 각 속성들을 따로 지정할 수도 있지만, 속기형으로 빠르게 지정할 수 도 있다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;font-속기형-작성법&quot;&gt;font 속기형 작성법&lt;/h2&gt;
&lt;p&gt;font 속기형 작성법에는 필수 지정 요소들이 존재하며, 옵션 요소들의 경우 작성하는 
방법이 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;필수요소: &lt;em&gt;font-size&lt;/em&gt; 와 &lt;em&gt;font-family&lt;/em&gt;는 필수로 지정해야한다.
    &lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;font&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;10px&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&quot;Times New Roman&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;옵션요소: &lt;em&gt;line-height&lt;/em&gt;를 지정할 때는 &lt;em&gt;font-size&lt;/em&gt;뒤에 슬래시(/)를
붙이고 그 뒷부분에 작성한다.
    &lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;font&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.5&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&quot;Times New Roman&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;옵션요소: &lt;em&gt;font-weight&lt;/em&gt;, &lt;em&gt;font-style&lt;/em&gt;, &lt;em&gt;font-variant&lt;/em&gt;등은 &lt;em&gt;font-size&lt;/em&gt;
앞부분에 작성한다.
    &lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;font&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;bold&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;italic&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;small-caps&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.5&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&quot;Times New Roman&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonbin Kim</name></author><category term="css" /><summary type="html">CSS에서 font의 특성을 지정하는 속성들과 이를 빠르게 작성할 수 있는 속기형 작성법에 대해 포스팅하려 한다. CSS에서 글자 스타일을 지정하는 속성들 글꼴: font-family 크기: font-size 행간: line-height 기울기: font-style 두께: font-weight 음절 앞 글자 대문자: font-variant(영문 글꼴에만 적용) 예시 font-family: &quot;Times New Roman&quot;; font-size: 10px; line-height: 1.5; font-style: italic; font-weight: bold; font-variant: small-caps; 예시 처럼 각 속성들을 따로 지정할 수도 있지만, 속기형으로 빠르게 지정할 수 도 있다. font 속기형 작성법 font 속기형 작성법에는 필수 지정 요소들이 존재하며, 옵션 요소들의 경우 작성하는 방법이 존재한다. 필수요소: font-size 와 font-family는 필수로 지정해야한다. font: 10px &quot;Times New Roman&quot;; 옵션요소: line-height를 지정할 때는 font-size뒤에 슬래시(/)를 붙이고 그 뒷부분에 작성한다. font: 10px/1.5 &quot;Times New Roman&quot;; 옵션요소: font-weight, font-style, font-variant등은 font-size 앞부분에 작성한다. font: bold italic small-caps 10px/1.5 &quot;Times New Roman&quot;;</summary></entry><entry><title type="html">[Error] DPI-1047 : node.js 와 oracle client의 호환문제</title><link href="http://localhost:4000/err-node-oracle-bit-dif.html" rel="alternate" type="text/html" title="[Error] DPI-1047 : node.js 와 oracle client의 호환문제" /><published>2020-02-29T00:00:00+09:00</published><updated>2020-02-29T00:00:00+09:00</updated><id>http://localhost:4000/err-node-oracle-bit-dif</id><content type="html" xml:base="http://localhost:4000/err-node-oracle-bit-dif.html">&lt;h2 id=&quot;배경&quot;&gt;배경&lt;/h2&gt;
&lt;p&gt;node.js에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;oracledb&lt;/code&gt;모듈을 사용하는데 아래와 같은 오류가 발생했다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Error: DPI-1047: Cannot locate a 64-bit Oracle Client library:
&quot;D:\app\kwb07\product\11.2.0\dbhome_1\bin\oci.dll is not the correct architecture&quot;. 
See https://oracle.github.io/odpi/doc/installation.html#windows for help
Node-oracledb installation instructions: https://oracle.github.io/node-oracledb/INSTALL.html
You must have 64-bit Oracle client libraries in your PATH environment variable.
If you do not have Oracle Database on this computer, then install the Instant Client 
Basic or Basic Light package from
http://www.oracle.com/technetwork/topics/winx64soft-089540.html
A Microsoft Visual Studio Redistributable suitable for your Oracle client library 
version must be available.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;local 컴퓨터에 32bit 오라클과 64bit node.js 가 설치되어있는 상황에서 
node.js와 오라클에서 기본으로 제공하는 클라이언트 툴 사이의 호환이 되지 않아 
이와 같은 오류가 발생한것이다.&lt;/p&gt;

&lt;p&gt;해결방법은 간단하다.&lt;br /&gt;
&lt;em&gt;64bit Oracle Instant Client 를 다운받아 환경 변수 설정을 한다.&lt;/em&gt; 
만약 32bit가 필요하다면 32bit Instant Client를 받으면 된다.&lt;/p&gt;

&lt;h2 id=&quot;1-instant-client-다운받기&quot;&gt;1. Instant Client 다운받기&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.oracle.com/kr/database/technologies/instant-client/downloads.html&quot;&gt;Oracle에서 받는다.&lt;/a&gt; 
자신에게 해당되는 버전을 선택하고 &lt;em&gt;Basic Package&lt;/em&gt;와 &lt;em&gt;SDK Package&lt;/em&gt;를 받으면 된다.&lt;/p&gt;

&lt;p&gt;두 압축파일을 풀어 하나의 폴더로 합치면 끝.&lt;/p&gt;

&lt;h2 id=&quot;2-환경변수-설정&quot;&gt;2. 환경변수 설정&lt;/h2&gt;
&lt;p&gt;앞에서 합친 폴더를 시스템 환경변수의 &lt;em&gt;Path&lt;/em&gt; 변수에 추가한다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="err" /><category term="oracle" /><category term="node.js" /><summary type="html">배경 node.js에서 oracledb모듈을 사용하는데 아래와 같은 오류가 발생했다. Error: DPI-1047: Cannot locate a 64-bit Oracle Client library: &quot;D:\app\kwb07\product\11.2.0\dbhome_1\bin\oci.dll is not the correct architecture&quot;. See https://oracle.github.io/odpi/doc/installation.html#windows for help Node-oracledb installation instructions: https://oracle.github.io/node-oracledb/INSTALL.html You must have 64-bit Oracle client libraries in your PATH environment variable. If you do not have Oracle Database on this computer, then install the Instant Client Basic or Basic Light package from http://www.oracle.com/technetwork/topics/winx64soft-089540.html A Microsoft Visual Studio Redistributable suitable for your Oracle client library version must be available. local 컴퓨터에 32bit 오라클과 64bit node.js 가 설치되어있는 상황에서 node.js와 오라클에서 기본으로 제공하는 클라이언트 툴 사이의 호환이 되지 않아 이와 같은 오류가 발생한것이다. 해결방법은 간단하다. 64bit Oracle Instant Client 를 다운받아 환경 변수 설정을 한다. 만약 32bit가 필요하다면 32bit Instant Client를 받으면 된다. 1. Instant Client 다운받기 Oracle에서 받는다. 자신에게 해당되는 버전을 선택하고 Basic Package와 SDK Package를 받으면 된다. 두 압축파일을 풀어 하나의 폴더로 합치면 끝. 2. 환경변수 설정 앞에서 합친 폴더를 시스템 환경변수의 Path 변수에 추가한다.</summary></entry><entry><title type="html">[Node.js] oracledb 모듈을 이용해 ORACLE 사용하기</title><link href="http://localhost:4000/nodejs-oracledb-how-to-connect.html" rel="alternate" type="text/html" title="[Node.js] oracledb 모듈을 이용해 ORACLE 사용하기" /><published>2020-02-27T00:00:00+09:00</published><updated>2020-02-27T00:00:00+09:00</updated><id>http://localhost:4000/nodejs-oracledb-how-to-connect</id><content type="html" xml:base="http://localhost:4000/nodejs-oracledb-how-to-connect.html">&lt;hr /&gt;
&lt;h2 id=&quot;1-oracledb-모듈-불러오기-oracledb-객체-생성&quot;&gt;1. &lt;a href=&quot;https://oracle.github.io/node-oracledb/doc/api.html#-3-oracledb-class&quot;&gt;Oracledb 모듈 불러오기: Oracledb 객체 생성&lt;/a&gt;&lt;/h2&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;oracledb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;oracledb&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 oracledb 모듈을 불러오면 &lt;code class=&quot;highlighter-rouge&quot;&gt;oracledb&lt;/code&gt;라는 변수에는 
oracledb 객체의 포인터가 저장된다. 즉 하나의 프로세스에서 여러개의 변수로 
oracledb 모듈을 불러와도 모두 같은 객체를 참조하는것이다.&lt;/p&gt;

&lt;h3 id=&quot;11-oracledb-객체는-무엇을-하는가&quot;&gt;1.1 oracledb 객체는 무엇을 하는가?&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Pool&lt;/em&gt; 객체와 &lt;em&gt;Connection&lt;/em&gt; 객체를 생성할 기반의 역할을 하고 
DB관련 작업시 사용할 많은 &lt;a href=&quot;https://oracle.github.io/node-oracledb/doc/api.html#-31-oracledb-constants&quot;&gt;상수들을 갖고있다.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Pool&lt;/em&gt; 과 &lt;em&gt;Connection&lt;/em&gt; 객체는 DB와의 통신을 생성하고 관리하는 역할을 한다.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;2-pool-생성하기&quot;&gt;2. Pool 생성하기&lt;/h2&gt;

&lt;h3 id=&quot;21-pool의-개념&quot;&gt;2.1 Pool의 개념&lt;/h3&gt;
&lt;p&gt;문서에 따르면 각각의 Pool 객체는 &lt;em&gt;&lt;a href=&quot;https://docs.oracle.com/en/database/oracle/oracle-database/19/lnoci/session-and-connection-pooling.html#GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C&quot;&gt;Oracle Call Interface Session Pool&lt;/a&gt;&lt;/em&gt; 라고 한다.&lt;br /&gt;
이 Pool객체는 DB에 연결하기 위한 속성들을 저장하고 있으며 연결을 유지시켜 놓고 관리한다.&lt;br /&gt;
이런 특성의 장점은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;여러개의 연결이 발생할때 중복 사용되는 데이터를 Pool이 처리해 준다.&lt;/li&gt;
  &lt;li&gt;새로운 연결을 만들때의 대기시간이나 자원낭비가 없다.(Pool객체가 DB와의 연결을 
유지하고 있다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-생성하기-oracledbcreatepool&quot;&gt;2.2 생성하기: &lt;a href=&quot;https://oracle.github.io/node-oracledb/doc/api.html#createpool&quot;&gt;oracledb.createPool()&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;oracledb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;poolAttrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Pool&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 oracledb 객체에 속한 함수를 통해 콜백방법으로 생성할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;221-parameters-object-poolattrs&quot;&gt;2.2.1 Parameters: Object poolAttrs&lt;/h4&gt;
&lt;p&gt;Pool을 생성하는데 필요한 세부사항들을 key:value(javascript 객체)
로 정의한 객체이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://oracle.github.io/node-oracledb/doc/api.html#-3311-createpool-parameters-and-attributes&quot;&gt;문서&lt;/a&gt;를 보면 여러가지 속성들을 찾을수 있다. 
이 글에서는 중요한 속성들만 언급하려한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;속성 이름&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;connectString&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;tnsnames.ora에 등록된 서비스 이름이 &lt;em&gt;MYDB&lt;/em&gt;이고 리스너가 &lt;em&gt;localhost:1521&lt;/em&gt;에 위치해 있다면 값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;localhost:1521/MYDB&quot;&lt;/code&gt;가 될 것이다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;user&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;사용하려는 Oracle 계정의 이름이다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;password&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;위 user의 패스워드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;poolAlias&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;생성되는 &lt;em&gt;Pool&lt;/em&gt;은 &lt;em&gt;Connection Pool Cache&lt;/em&gt;에 등록되는데 이때 해당 &lt;em&gt;Pool&lt;/em&gt;을 구별하는 식별자의 역할을 하는것이 &lt;em&gt;poolAlias&lt;/em&gt;이다. &lt;em&gt;oracledb.getPool()&lt;/em&gt;등의 함수에 파라미터로 전달하여 해당 &lt;em&gt;Pool&lt;/em&gt;을 얻을수 있다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이것들 외에도 Pool에서 관리할 Conection의 개수를 제한하거나, 
관리되는 Connection들에 같은 속성을 부여할 것 인지 설정하는등 
여러가지를 설정할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;222-callback-function&quot;&gt;2.2.2 Callback function&lt;/h4&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Pool&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Parameter&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Error error&lt;/td&gt;
      &lt;td&gt;createPool()이 성공한다면 NULL값이지만 실패한다면 &lt;a href=&quot;https://oracle.github.io/node-oracledb/doc/api.html#errorobj&quot;&gt;오류 메세지&lt;/a&gt;를 포함한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://oracle.github.io/node-oracledb/doc/api.html#poolclass&quot;&gt;Pool&lt;/a&gt; pool&lt;/td&gt;
      &lt;td&gt;새로 생성된 connection Pool이다. Pool 생성을 실패했다면 NULL 값을 가진다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;3-connection-만들기-oracledbgetconnection&quot;&gt;3. Connection 만들기: oracledb.getConnection()&lt;/h2&gt;
&lt;p&gt;getConnection() 합수는 여러 종류가 있어서 Pool 없이 연결을 만들수도 있다. 
하지만 Pool을 사용하는 것이 Oracle의 권장사항이어서 Pool을 사용하는 콜백방법에 
대해서만 알아보려한다. 다른 방법들은 &lt;a href=&quot;https://oracle.github.io/node-oracledb/doc/api.html#-332-oracledbgetconnection&quot;&gt;이곳&lt;/a&gt;에 있다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;oracledb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getConnection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;poolAlias&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Connection&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 oracledb객체의 메소드로 Connection을 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;poolAlias는 위에서 언급한 ‘pool을 식별하는 문자열’이다. poolAlias를 파라미터로 전달하지 
않으면 가장 최근에 Pool cache에 올라간 Pool을 사용한다.&lt;/p&gt;

&lt;p&gt;콜백함수의 error 파라미터는 
connection 생성에 성공하면 NULL이고, 실패하면 Error 객체가 된다.&lt;br /&gt;
생성에 실패하면 Connection 객체는 NULL값으로 들어온다.&lt;/p&gt;

&lt;!-- ## 4. SQL 실행하기: connection.execute()생성된 connection객체에서 execute()함수를 통해 쿼리를 실행할 수 있다.  --&gt;</content><author><name>Wonbin Kim</name></author><category term="node.js" /><category term="oracle" /><summary type="html">1. Oracledb 모듈 불러오기: Oracledb 객체 생성 const oracledb = require(&quot;oracledb&quot;); 위와 같이 oracledb 모듈을 불러오면 oracledb라는 변수에는 oracledb 객체의 포인터가 저장된다. 즉 하나의 프로세스에서 여러개의 변수로 oracledb 모듈을 불러와도 모두 같은 객체를 참조하는것이다. 1.1 oracledb 객체는 무엇을 하는가? Pool 객체와 Connection 객체를 생성할 기반의 역할을 하고 DB관련 작업시 사용할 많은 상수들을 갖고있다. Pool 과 Connection 객체는 DB와의 통신을 생성하고 관리하는 역할을 한다. 2. Pool 생성하기 2.1 Pool의 개념 문서에 따르면 각각의 Pool 객체는 Oracle Call Interface Session Pool 라고 한다. 이 Pool객체는 DB에 연결하기 위한 속성들을 저장하고 있으며 연결을 유지시켜 놓고 관리한다. 이런 특성의 장점은 다음과 같다. 여러개의 연결이 발생할때 중복 사용되는 데이터를 Pool이 처리해 준다. 새로운 연결을 만들때의 대기시간이나 자원낭비가 없다.(Pool객체가 DB와의 연결을 유지하고 있다.)</summary></entry><entry><title type="html">[Oracle] Table 생성과 제약조건 (선언적 무결성 제약조건 추가하기)</title><link href="http://localhost:4000/oracle-create-table.html" rel="alternate" type="text/html" title="[Oracle] Table 생성과 제약조건 (선언적 무결성 제약조건 추가하기)" /><published>2020-02-20T00:00:00+09:00</published><updated>2020-02-20T00:00:00+09:00</updated><id>http://localhost:4000/oracle-create-table</id><content type="html" xml:base="http://localhost:4000/oracle-create-table.html">&lt;p&gt;Oracle에서 Table을 생성하고 제약조건을 추가하는 방법을 공부했다. 
그 방법을 정리하려 포스팅을 하게 되었다.&lt;/p&gt;

&lt;h2 id=&quot;테이블-만들기-기본적인-형태&quot;&gt;테이블 만들기: 기본적인 형태&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table [스키마.]&amp;lt;테이블 이름&amp;gt; (
&amp;lt;열 이름&amp;gt; &amp;lt;데이터 타입&amp;gt; [default &amp;lt;표현식&amp;gt;] [&amp;lt;제약조건&amp;gt;]
[,&amp;lt;열 이름&amp;gt; &amp;lt;데이터 타입&amp;gt; [default &amp;lt;표현식&amp;gt;] [&amp;lt;제약조건&amp;gt;]]
[,...]
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[]: 선택사항&lt;br /&gt;
&amp;lt;&amp;gt;: 필수사항&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;스키마&lt;/em&gt;: 만들어질 테이블이 속하는 스키마&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;테이블 이름&lt;/em&gt;: 만들어질 테이블의 이름&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;열 이름&lt;/em&gt;: 테이블의 열 이름&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;데이터 타입&lt;/em&gt;: 해당하는 열의 데이터 타입&lt;/li&gt;
  &lt;li&gt;*default &lt;표현식&gt;*: insert 구문에서 열의 값이 지정되지 않는 경우 
디폴트 값을 지정한다. &lt;표현식&gt;에는 정적값이나 sql함수를 지정할 수 있다.&lt;/표현식&gt;&lt;/표현식&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;제약조건&lt;/em&gt;: 각 열의 데이터가 갖춰야할 제약조건을 정의할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;테이블-만들기-select-구문-이용&quot;&gt;테이블 만들기: select 구문 이용&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;create table &amp;lt;table name&amp;gt; as select...&lt;/code&gt;형태의 구문으로 
select를 사용해 table을 생성할 수 있다.&lt;br /&gt;
&lt;strong&gt;예시&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table another_dept
as select * from scott.dept;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;제약조건이란&quot;&gt;제약조건이란?&lt;/h2&gt;
&lt;p&gt;Oracle은 데이터베이스의 데이터가 의도한 대로 저장되고 
데이터베이스의 다른 부분과 결함없이 작동하도록 제약조건을 제공한다.&lt;/p&gt;

&lt;p&gt;이때 제약조건을 적용하는 방법을 두가지로 분류할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;선언적 방법&lt;/strong&gt;: 
테이블의 선언(생성 및 변경)과 함께 규칙을 저장한다. 
테이블간의 관계에 대한 규칙, 테이블 열에 들어가야할 데이터의 규칙등을 지정한다. 
테이블에 저장되는 모든 행에 적용된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;절차적 방법&lt;/strong&gt;: 
작업과정중에는 데이터에 제약조건을 추가해야하는 상황이 발생하며 선언적 
방법만으로는 이를 충족하기 어렵다. 따라서 절차적 방법으로 
데이터에 제약조건을 추가하는데 이를 &lt;em&gt;사용자 정의 무결성&lt;/em&gt; 이라고 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 글에서는 Oracle의 &lt;strong&gt;선언적 무결성 제약조건&lt;/strong&gt; 추가방법을 알아보려한다.&lt;br /&gt;
Table을 새로 생성할때는 &lt;code class=&quot;highlighter-rouge&quot;&gt;create table&lt;/code&gt; 구문에서 제약조건을 추가 할 수 있다(앞에서 살펴봤다).&lt;br /&gt;
이미 존재하는 Table에 제약조건을 추가할 때는 아래와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;alter table add&lt;/code&gt;를 사용한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alter table [스키마.]&amp;lt;Table이름&amp;gt;
add [constraint &amp;lt;제약조건의 이름&amp;gt;]
&amp;lt;제약조건 정의&amp;gt;
/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;제약조건-추가하기-1-기본키-추가&quot;&gt;제약조건 추가하기: 1. 기본키 추가&lt;/h2&gt;
&lt;p&gt;기본키는 Table에서 각각의 행을 구분짓는 키의 역할을 한다. 
따라서 NULL이 될 수 없고 행을 구분 지을수 있도록 유일한 것 이어야 한다.&lt;br /&gt;
기본키는 하나의 열이나 여러개 열의 모음으로 정의할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 생성시 기본키 정의&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this_is_test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 sql을 실행한 결과는 아래와 같은데 NO 항목이 기본키(Primary Key)로 
정의된 것을 확인할 수 있다.&lt;br /&gt;
&lt;img src=&quot;/assets/img/2020-02-20-oracle-create-table/pk1.png&quot; alt=&quot;pk&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이미 생성된 Table에 기본키 제약조건 적용&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this_is_test&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constraint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ct_name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;제약조건-추가하기-2-외부키-추가&quot;&gt;제약조건 추가하기: 2. 외부키 추가&lt;/h2&gt;
&lt;p&gt;외부키는 다른 Table과 연결되는 기능을 한다.&lt;br /&gt;
이때 테이블간에 부모-자식 관계가 발생한다. 제약조건이 적용되는 테이블은 
자식이고 그것이 아닌쪽이 부모이다.&lt;/p&gt;

&lt;p&gt;외부키를 적용할때 &lt;code class=&quot;highlighter-rouge&quot;&gt;references&lt;/code&gt;라는 키워드로 부모 테이블과 연결 시킨다.&lt;/p&gt;

&lt;p&gt;이미 존재하는 테이블에는 다음과 같이 사용한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
alter table [스키마.]&amp;lt;Table이름&amp;gt;
add [constraint &amp;lt;제약조건의 이름&amp;gt;]
foreign key (&amp;lt;외부키에 해당되는 한 열 또는 여러 열&amp;gt;)
references &amp;lt;부모테이블 이름&amp;gt; (&amp;lt;외부키와 연결되는 한 열 또는 여러 열&amp;gt;)
/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테이블 생성시 외부키 정의방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;references&lt;/code&gt;키워드만 사용한다.&lt;br /&gt;
&lt;strong&gt;테이블 생성 예시&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;references&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;제약조건-추가하기-3-유일조건-추가&quot;&gt;제약조건 추가하기: 3. 유일조건 추가&lt;/h2&gt;
&lt;p&gt;유일조건은 지정하는 열들이 NULL값이 아닐때 
테이블내에서 행마다 유일하도록 하는 제약조건이다.&lt;br /&gt;
곧 행을 구분할 수 있는 수단이 될 수 있다.&lt;/p&gt;

&lt;p&gt;다음의 방법으로 사용하면 된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unique(&amp;lt;열1&amp;gt;[,&amp;lt;열2&amp;gt;][,...])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;제약조건-추가하기-4-check조건-추가&quot;&gt;제약조건 추가하기: 4. CHECK조건 추가&lt;/h2&gt;
&lt;p&gt;이 조건은 테이블 내의 모든 행에 적용되는 조건이다.&lt;br /&gt;
대상이 되는 행이 check 조건을 만족해야한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;people_who_is_male&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constraint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;check_gender&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gender&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'MALE'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 예시에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;gender&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;people_who_is_male&lt;/code&gt;테이블의 
열이다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="oracle" /><category term="sql" /><summary type="html">Oracle에서 Table을 생성하고 제약조건을 추가하는 방법을 공부했다. 그 방법을 정리하려 포스팅을 하게 되었다. 테이블 만들기: 기본적인 형태</summary></entry><entry><title type="html">[Oracle] 스키마 생성, 권한부여, 수정, 삭제</title><link href="http://localhost:4000/oracle-user-create-grant-alter.html" rel="alternate" type="text/html" title="[Oracle] 스키마 생성, 권한부여, 수정, 삭제" /><published>2020-02-19T00:00:00+09:00</published><updated>2020-02-19T00:00:00+09:00</updated><id>http://localhost:4000/oracle-user-create-grant-alter</id><content type="html" xml:base="http://localhost:4000/oracle-user-create-grant-alter.html">&lt;h2 id=&quot;사용자-생성하기-create-user&quot;&gt;사용자 생성하기: ‘create user’&lt;/h2&gt;
&lt;p&gt;oracle에서 사용자(스키마)를 생성하기 위해선 create user 
명령을 사용한다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;identified&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;사용자에게-권한-부여하기&quot;&gt;사용자에게 권한 부여하기&lt;/h2&gt;
&lt;p&gt;oracle에서 사용자에게 권한을 부여하기 위해선 &lt;code class=&quot;highlighter-rouge&quot;&gt;grant ... to ...&lt;/code&gt;
명령을 사용한다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;권한&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;권한&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;사용자-관련-사항-수정하기-alter-user&quot;&gt;사용자 관련 사항 수정하기: alter user&lt;/h2&gt;
&lt;p&gt;사용자 계정과 관련된 사항을 수정할때는 &lt;code class=&quot;highlighter-rouge&quot;&gt;alter user&lt;/code&gt;로 시작하는 
구문을 이용해 수정한다.&lt;/p&gt;
&lt;h3 id=&quot;1-암호-변경하기&quot;&gt;1. 암호 변경하기&lt;/h3&gt;
&lt;p&gt;사용자를 생성할때 사용한 암호 정의 구문을 이용한다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;identified&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-계정-잠금해제&quot;&gt;2. 계정 잠금/해제&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;3-테이블-스페이스-변경&quot;&gt;3. 테이블 스페이스 변경&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;defualt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tablespace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;space&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;temporary&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tablespace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;space&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;4-테이블-스페이스-할당량-변경&quot;&gt;4. 테이블 스페이스 할당량 변경&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;quota &amp;lt;할당량&amp;gt; on &amp;lt;tablespace 이름&amp;gt;&lt;/code&gt;을 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;quota&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlimited&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;quota&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;temp&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;사용자-삭제하기&quot;&gt;사용자 삭제하기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;drop user&lt;/code&gt; 명령을 사용한다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="oracle" /><category term="sql" /><summary type="html">사용자 생성하기: ‘create user’ oracle에서 사용자(스키마)를 생성하기 위해선 create user 명령을 사용한다. create user &amp;lt;user name&amp;gt; identified by &amp;lt;user password&amp;gt;; 사용자에게 권한 부여하기 oracle에서 사용자에게 권한을 부여하기 위해선 grant ... to ... 명령을 사용한다. grant &amp;lt;권한1&amp;gt;, &amp;lt;권한2&amp;gt;,... to &amp;lt;user name&amp;gt;;</summary></entry><entry><title type="html">이벤트 기반 비동기 방식이란? 어떻게 동작하는거지? Node.js Javascript</title><link href="http://localhost:4000/nodejs-what-is-event-based-programming.html" rel="alternate" type="text/html" title="이벤트 기반 비동기 방식이란? 어떻게 동작하는거지? Node.js Javascript" /><published>2020-02-07T00:00:00+09:00</published><updated>2020-02-07T00:00:00+09:00</updated><id>http://localhost:4000/nodejs-what-is-event-based-programming</id><content type="html" xml:base="http://localhost:4000/nodejs-what-is-event-based-programming.html">&lt;h1 id=&quot;배경&quot;&gt;배경&lt;/h1&gt;
&lt;p&gt;Node.js를 처음 접했을때 &lt;em&gt;이벤트 기반 비동기 처리&lt;/em&gt; 방식을
사용한다는 사실을 알게됐다. &lt;em&gt;모던 웹을 위한 Node.js 프로그래밍&lt;/em&gt;
이라는 책에서는 이 방식을 아래의 &lt;em&gt;시장 대기표&lt;/em&gt; 예시로
설명했다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;시장 여러곳의 가게에서 물건을 구매해야한다.&lt;br /&gt;
이때 각 가게에는 손님들이 줄을 서서 대기하고 있다.&lt;br /&gt;
빠르게 모든 물건을 구매하기 위해선 두가지 방법이 있는데&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;몸을 복제해 동시에 여러가게에 간다.&lt;/li&gt;
  &lt;li&gt;시장을 대기표를 나누어주는 시스템으로 바꾸고
대기표만 받고 기다린다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1번의 방식은 기존의 스레드 기반 네트워크 프로그램의 방식이며,&lt;br /&gt;
2번은 이벤트 기반 비동기 방식이다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;이 예시를 통해서 이벤트 기반 비동기 방시기 어떤
방식인지 이해할 순 있었다. 하지만 이것이 어떻게 가능한지,
진짜 단일 스레드로 가능한건지 궁금해졌다.&lt;/p&gt;

&lt;h1 id=&quot;multi-thread-방식&quot;&gt;Multi Thread 방식&lt;/h1&gt;
&lt;p&gt;Multi Thread 방식의 서버의 요청처리는 각 요청마다
새로운 Thread를 발생시켜 처리하는 방식이다.
아래의 java코드로 이해해 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//server-socket 80번 포트에서 bind&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ServerSocket&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServerSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//연결 생성&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Socket&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//새로운 스레드 발생시켜 처리과정 넘기기&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;MutiThreadHttp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutiThreadHttp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//스레드 시작             &lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 방식은 클라이언트 요청이 몰릴수록 그에 대응되는 많은
스레드가 발생하므로 메모리 자원을
많이 소모하게 된다. 즉 서버의 자원에 제한을 받는다.&lt;br /&gt;
또 프로그래밍시 Thread간 공유자원 관리에 주의 해야하는
단점이 있다.&lt;/p&gt;

&lt;h1 id=&quot;이벤트-기반-비동기-방식&quot;&gt;이벤트 기반 비동기 방식&lt;/h1&gt;
&lt;p&gt;javascript는 이벤트 기반 비동기 방식으로 작동한다.&lt;br /&gt;
이 방식을 따르는 Node.js는 여러 클라이언트들의 요청을
하나의 스레드로 처리하며 각각의 요청에서 이벤트가 발생할 때만 그에 맞는 작업을 처리한다.&lt;/p&gt;

&lt;p&gt;어떠한 원리로 이벤트 기반 비동기 방식이 작동하는지 궁금해졌고
아래의 문서들을 통해 이해할 수 있었다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40&quot;&gt;Understanding JS: The Event Loop&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.nextree.co.kr/p7292/&quot;&gt;Node.js: 비동기 프로그래밍 이해&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이벤트 기반 비동기 방식은 &lt;strong&gt;Event Loop&lt;/strong&gt;에 의해 이루어진다.
Node.js에서 클라이언트의 요청을 처리하는 방식을 보면
이해할 수 있다.&lt;br /&gt;
&lt;img src=&quot;/assets/img/what-is-event-based-programming-javascript.jpg&quot; alt=&quot;eventbased-eg-req&quot; /&gt;&lt;br /&gt;
위와같이 할 수 있는 이유는 요청에서 발생하는 이벤트와 콜백들을
이벤트 루프에서 처리하기 때문이다.
이 과정을 이해하려면 Call Stack, Event Table, Event Queue
에 대해 알아야한다.&lt;/p&gt;

&lt;h2 id=&quot;call-stack&quot;&gt;Call Stack&lt;/h2&gt;
&lt;p&gt;Javascript에서 함수를 호출하게 되면 이를 Callstack에 넣는다.&lt;br /&gt;
이름 그대로 Stack이므로 나중에 들어간 함수가 먼저 실행되고
먼저들어간 함수가 나중에 실행된다.&lt;br /&gt;
실행중인 함수가 다른 함수를 호출하면 호출받은 함수가
Callstack의 맨 위에 올려진다.&lt;/p&gt;

&lt;p&gt;Javascript는 오직 하나의 Callstack을 가져서 모든 함수의 실행은
Callstack에서 이루어진다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 Callstack만으로는 javascript가 이벤트를 비동기처리 하는
과정을 설명할 수 없다.&lt;br /&gt;
예를들어 10초후에 특정함수가 실행되도록 타이머를 설정한다면,
모든 처리가 10초 늦춰진다고 밖에 설명할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;event-table-event-queue&quot;&gt;Event Table, Event Queue&lt;/h2&gt;
&lt;p&gt;위의 예시와같이 이벤트가 발생해야 실행되는 함수를 Event Table
에서 저장한다. 이때 Event Table은 특정 이벤트와 그에 대응되는
함수를 저장하고 이벤트가 발생하면 대응되는 함수를 Event Queue에
넣는다.&lt;/p&gt;

&lt;p&gt;Event Queue는 말 그대로 ‘큐’이므로 들어온 순서대로 함수를
수행한다.&lt;br /&gt;
하지만 함수를 실행시키는것은 Callstack에 쌓인 함수만 가능하므로
아직 수행해야할 작업이 남아있다.&lt;/p&gt;

&lt;h2 id=&quot;event-loop&quot;&gt;Event Loop&lt;/h2&gt;
&lt;p&gt;Event Loop는 이벤트에 대응되는 함수를 Callstack에 쌓는
역할을 한다.&lt;br /&gt;
작업의 과정은 다음과 같이 진행된다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Callstack이 비어있는지 확인한다.&lt;/li&gt;
  &lt;li&gt;비어있다면 Event Queue가 비어있는지 확인한다.&lt;/li&gt;
  &lt;li&gt;큐가 비어있지 않다면 Event Queue의 앞에서 함수를 가져와 Callstack에 쌓는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;결론&quot;&gt;결론&lt;/h1&gt;
&lt;p&gt;전체적으로 Event Loop를 통해 이벤트 기반 비동기 방식이 작동한다.&lt;br /&gt;
곧 코드작성자의 코드가 하나의 Thread에 기반해서 실행될 수 있도록
내부적으로 여러개의 Thread를 발생시키는 방법인것이다.&lt;/p&gt;

&lt;p&gt;지금까지 살펴본 Event Loop의 작업방식을 확인해 볼 수 있는
코드가 있다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;실행시켜보면 ‘second’가 먼저 출력되고 ‘first’가 나중에 출력된다.&lt;br /&gt;
다음의 과정으로 처리가 된 것이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;setTimeout()이 호출되어 콜스택에서 실행된다.&lt;/li&gt;
  &lt;li&gt;event table에 ‘first’출력 함수가 저장된다.&lt;/li&gt;
  &lt;li&gt;‘second’출력이 콜스텍에 올라가고 ‘first’출력이 이벤트 큐에 올라간다.&lt;/li&gt;
  &lt;li&gt;Event Loop는 콜스텍이 비어야 Event Queue에서 함수를 꺼내오므로 ‘second’출력이 먼저 발생하고 ‘first’출력이 콜스텍에 올라가 실행된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이벤트 기반 비동기 방식은 Multi Thread 방식보다 Thread를 적게
사용하여 메모리 자원을 절약할 수 있는 이점이 있다.&lt;br /&gt;
하지만 각각의 이벤트들이 많은 연산이 필요하거나 대용량의 IO를
다루는 작업등의 많은 시간이 필요한 작업이라면 성능의 저하를
가져올 수 있다.&lt;/p&gt;

&lt;p&gt;프로그래밍시 주의해야 할 점은 javascript가 비동기 언어라는
점을 꼭 인식해야한다는 것이다.&lt;br /&gt;
자신이 작성한 코드중 무엇이 먼저 실행될지 모르기 때문에
콜백방법을 이용하여 순차적으로 실행되도록 해야한다.&lt;br /&gt;
또, 콜백함수를 받는 함수를 작성할때도 비동기적 방식으로 처리된다는
것을 유의하고 콜백함수를(콜백을 쓰거나 다른 라이브러리를 사용하여)
원하는 시점에 실행시키도록 주의해야한다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="node.js" /><category term="javascript" /><summary type="html">배경 Node.js를 처음 접했을때 이벤트 기반 비동기 처리 방식을 사용한다는 사실을 알게됐다. 모던 웹을 위한 Node.js 프로그래밍 이라는 책에서는 이 방식을 아래의 시장 대기표 예시로 설명했다. 시장 여러곳의 가게에서 물건을 구매해야한다. 이때 각 가게에는 손님들이 줄을 서서 대기하고 있다. 빠르게 모든 물건을 구매하기 위해선 두가지 방법이 있는데 몸을 복제해 동시에 여러가게에 간다. 시장을 대기표를 나누어주는 시스템으로 바꾸고 대기표만 받고 기다린다.</summary></entry><entry><title type="html">[Node.js] 전역 변수, 전역 객체 (console, process, exports)</title><link href="http://localhost:4000/nodejs-global-objects.html" rel="alternate" type="text/html" title="[Node.js] 전역 변수, 전역 객체 (console, process, exports)" /><published>2020-02-03T00:00:00+09:00</published><updated>2020-02-03T00:00:00+09:00</updated><id>http://localhost:4000/nodejs-global-objects</id><content type="html" xml:base="http://localhost:4000/nodejs-global-objects.html">&lt;p&gt;이 글은 Node.js의 전역 변수와 전역 객체를
정리한 글 입니다.&lt;/p&gt;

&lt;h1 id=&quot;전역-변수&quot;&gt;전역 변수&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__filename&lt;/code&gt;: 현재 실행중인 코드의 파일 경로를 가지는 문자열&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__dirname&lt;/code&gt;: 현재 실행중인 코드의 디렉토리 경로를 가지는 문자열&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;console-객체&quot;&gt;console 객체&lt;/h1&gt;
&lt;p&gt;console 객체는 Node.js의 콘솔화면 기능을 다룹니다. console 객체의 메서드는 아래와 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;log()&lt;/code&gt;: print 기능을 가지며 특수문자를 
이용해 문자열을 출력할 수 있습니다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%d&lt;/code&gt;: 숫자&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;: 문자열&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%j&lt;/code&gt;: JSON&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;time(label)&lt;/code&gt;: 시간 측정을 시작합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timeEnd(label)&lt;/code&gt;: 시간 측정을 종료합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;예시 코드&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log(&quot;%d * %d = %s&quot;, 10, 10, '100');
console.log(&quot;json: %j&quot;, {&quot;name&quot; : &quot;rst&quot;});

console.time('t');
for(var i=0; i&amp;lt;99999; i++);
console.timeEnd('t');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;결과&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10 * 10 = 100
{&quot;name&quot;:&quot;rst}
t: 18172.890ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;process-객체&quot;&gt;process 객체&lt;/h1&gt;
&lt;p&gt;process 객체는 프로그램과 관련된 정보를 포함하는 객체입니다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;process 객체의 속성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;argv&lt;/code&gt;: 실행 매개 변수를 포함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;env&lt;/code&gt;: 컴퓨터 환경 정보 포함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;version&lt;/code&gt;: Node.js의 버전 정보&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;versions&lt;/code&gt;: Node.js와 종속된 프로그램의 버전 정보&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arch&lt;/code&gt;: 프로세서의 아키텍쳐&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;platform&lt;/code&gt;: 플랫포 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;process 객체의 메서드&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exit()&lt;/code&gt;: 프로그램 종료&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memoryUsage()&lt;/code&gt;: 메모리 사용 정보 객체를 리턴&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uptime()&lt;/code&gt;: 현재 프로그램이 실행된 시간을 리턴&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;exports-객체&quot;&gt;exports 객체&lt;/h1&gt;
&lt;p&gt;exports 객체는 모듈을 생성할때 사용합니다.&lt;br /&gt;
exports 객체의 속성을 정의하는 방식으로 작동합니다. 
예시를 보는것이 이해하기 쉽습니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;md.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;app.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;md&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./md.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;md&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;언급하지 않아도 되겠지만 결과는 &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;가 출력됩니다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="node.js" /><summary type="html">이 글은 Node.js의 전역 변수와 전역 객체를 정리한 글 입니다.</summary></entry><entry><title type="html">[Javascript] Callback 함수 with JQuery effect</title><link href="http://localhost:4000/javascript-callback-with-jquery-effect.html" rel="alternate" type="text/html" title="[Javascript] Callback 함수 with JQuery effect" /><published>2020-01-30T00:00:00+09:00</published><updated>2020-01-30T00:00:00+09:00</updated><id>http://localhost:4000/javascript-callback-with-jquery-effect</id><content type="html" xml:base="http://localhost:4000/javascript-callback-with-jquery-effect.html">&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;배경&quot;&gt;배경&lt;/h2&gt;
&lt;p&gt;javascript는 한 문장씩 순차적으로 실행되는 언어이다.
하지만 애니메이션등의 효과를 사용하게되면 효과를 모두 마치기 
전에 다음 문장이 실행됨을 볼 수 있다.&lt;br /&gt;
다음의 코드를 실행시켜보면 쉽게 이해할 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;click&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;click&lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pp&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;저는 알림이 뜨기전에 사라지고 싶어요&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;#click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;#pp&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slideUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;slow&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;어림도 없지!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div style=&quot;border-style: solid; border-color: green;&quot;&gt;
&lt;button id=&quot;click&quot;&gt;click&lt;/button&gt;
&lt;p id=&quot;pp&quot;&gt;저는 알림이 뜨기전에 사라지고 싶어요&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    $(&quot;#click&quot;).click(
        function(){
            $(&quot;#pp&quot;).slideUp(&quot;slow&quot;);
            alert(&quot;어림도 없지!&quot;);
        }
    );
&lt;/script&gt;

&lt;p&gt;이러한 문제는 애니메이션 효과뿐만이 아니라
javascript를 사용하는 여러순간에 발생할 수 있다.
이를 해결하기 위해 Callback기능을 이용한다.&lt;/p&gt;

&lt;h2 id=&quot;사용방법&quot;&gt;사용방법&lt;/h2&gt;
&lt;p&gt;애니메이션 효과의 경우 다음과 같은 형식으로 사용할 수 있다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;$(selector).effect(speed, callback)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;effect는 slideUp, hide와 같은 효과 함수들을 가리킨다.&lt;/li&gt;
  &lt;li&gt;callback은 함수이다. 효과가 다 끝나고 함수가 실행된다.&lt;br /&gt;
아래의 예시를 실행해보자&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;click&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;click&lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pp&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;저는 알림이 뜨기전에 사라지고 싶어요&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;#click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;#pp&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slideUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;slow&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
                &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;그렇게 하렴~&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
            
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div style=&quot;border-style: solid; border-color: green;&quot;&gt;
&lt;button id=&quot;clickk&quot;&gt;click&lt;/button&gt;
&lt;p id=&quot;pppp&quot;&gt;저는 알림이 뜨기전에 사라지고 싶어요&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    $(&quot;#clickk&quot;).click(
        function(){
            $(&quot;#pppp&quot;).slideUp(&quot;slow&quot;,
            function(){
                alert(&quot;그렇게 하렴~&quot;);
            });
        }
    );
&lt;/script&gt;

&lt;h2 id=&quot;마치며-새롭게-알게된점&quot;&gt;마치며, 새롭게 알게된점&lt;/h2&gt;
&lt;p&gt;javascript의 callback함수를 ‘애니메이션 효과’에 관련된 부분의 공부를 하면서 ‘순차적 실행’에 관련해서만 이해했었다. 하지만 조금더 깊게 공부를 해보니 
&lt;code class=&quot;highlighter-rouge&quot;&gt;$(selector).click(function(){...})&lt;/code&gt; 과 같은 jquery 구문도 callback을 
이용한다는 사실을 알게되었다.&lt;/p&gt;

&lt;p&gt;자바스크립트에서는 함수가 객체로 사용된다.
함수1이 함수2를 파라미터로 받고 실행중 혹은 실행 마지막( 애니메이션 효과가 끝날때 
처럼 )에서 함수2를 실행시킨다면 함수2를 콜백함수라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 개념은 함수형 프로그래밍의 개념이라는데 좀 더 찾아봐야겠다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="javascript" /><category term="jquery" /><summary type="html"></summary></entry><entry><title type="html">[HTML5] Outline과 Section</title><link href="http://localhost:4000/html5-outlines-and-section.html" rel="alternate" type="text/html" title="[HTML5] Outline과 Section" /><published>2020-01-18T00:00:00+09:00</published><updated>2020-01-18T00:00:00+09:00</updated><id>http://localhost:4000/html5-outlines-and-section</id><content type="html" xml:base="http://localhost:4000/html5-outlines-and-section.html">&lt;ul&gt;
  &lt;li&gt;이 글은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTML/HTML5_%EB%AC%B8%EC%84%9C%EC%9D%98_%EC%84%B9%EC%85%98%EA%B3%BC_%EC%9C%A4%EA%B3%BD&quot;&gt;MDN문서&lt;/a&gt;와 &lt;a href=&quot;https://m5designstudio.com/2013/orlando-web-design/html5-for-beginners-2&quot;&gt;M5 design studio&lt;/a&gt;를 참고하여 작성한 글 입니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gsnedders.html5.org/outliner/&quot;&gt;HTML5 Outliner&lt;/a&gt;을 이용하면 아웃라인을 확인할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;outline&quot;&gt;Outline&lt;/h1&gt;
&lt;p&gt;HTML5에서는 이전보다 파악하기 쉬운 아웃라인을 사용합니다. 
아웃라인은 ‘섹션의 계층구조(트리구조)’라고 이해할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;Section&lt;/h1&gt;
&lt;p&gt;HTML5에서는 명시적인 방법과 비명시적인 방법으로 문서를 부분(section)으로 나눌수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;명시적-섹션&quot;&gt;명시적 섹션&lt;/h2&gt;
&lt;p&gt;아래의 태그들을 사용합니다.
&lt;img src=&quot;https://m5designstudio.com/wp-content/uploads/2013/01/HTML5_website_structure.jpg&quot; alt=&quot;dd&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;도 섹션 태그입니다. 각 섹션은 제목(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;부터&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;)을 가질 수 있으며 제목은 섹션내의 가장 위에 위치한 태그만 해당합니다. 그 외의 제목태그들은 뒤에서 설명할 비명시적인 섹션을 만들어냅니다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;body&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;section&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;body-s&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;section&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;body-s-s&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/section&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/section&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;section&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;body-s-2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/section&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 코드는 아래의 아웃라인을 갖게됩니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. body
    1. body-s
        1. body-s-s
    2. body-s-2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이를 통해 섹션으로 계층구조가 나눠짐을 알 수 있습니다. 
하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;header&amp;gt;&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;태그는 웹문서의 주요 아웃라인에 속하지 않습니다. 즉, 이 태그들은 해당 html5 문서의 주요 맥락에서 벗어난 내용을 다루는 용도로 사용됩니다.&lt;/p&gt;
&lt;h2 id=&quot;비명시적-섹션&quot;&gt;비명시적 섹션&lt;/h2&gt;
&lt;p&gt;제목 태그(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;)는 자신이 속한 섹션의 첫번째 제목으로 정의되지 않았다면 비명시적(암묵적)으로 새로운 섹션으로 분류됩니다.&lt;/p&gt;</content><author><name>Wonbin Kim</name></author><category term="html5" /><category term="web" /><summary type="html">이 글은 MDN문서와 M5 design studio를 참고하여 작성한 글 입니다. HTML5 Outliner을 이용하면 아웃라인을 확인할 수 있습니다. Outline HTML5에서는 이전보다 파악하기 쉬운 아웃라인을 사용합니다. 아웃라인은 ‘섹션의 계층구조(트리구조)’라고 이해할 수 있습니다.</summary></entry></feed>